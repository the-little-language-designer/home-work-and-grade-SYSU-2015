#+TITLE:  cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* ===================================
* note the order of development
** 5th-instar
   * type of jo
   * more in epilog
     1. *current-free-address,primitive-string-heap*
   * colon semicolon
     1. ":" and ";" are used to read a string of words for compiler
        [looks like bar-ket but special]
     2. comment is handled here
        "<< >>" as the only way to do comment
   * compiler
     * make-jojo
       and macro for make-jojo
       1. macro system
       2. exception handling system
     * function about definition
       which leave data into memory
   * code written in cicada-nymph
     * use define-macro to implement
       if & else & then
     * test the interpreter by the factorial function
     * re-define execute-word & basic-REPL
       to protect macro & exception from be called from basic-REPL
* -----------------------------------
* note
** jo & jojo
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "珠珠" in Chinese]
** naming convention
   * a predicate of a type
     which denotes a subtype of that type
     uses that type as postfix
     such as
     "space-char?"
   * a function of a type
     uses that type as prefix
     such as
     "string-reverse"
     "string-equal?"
   * side-effect of structured data is postfixed by "!"
** convention in assembly code
   * using underline to compose big word from small words
   * using "$" as prefix and postfix separator
   * indentation level = 3
   * naming convention of jo
     | convention   | jo type  |
     |--------------+----------|
     | prefix "V__" | variable |
     | prefix "M__" | macro    |
   * but I use
     1. "zero" instead of "V__zero"
     2. "true" instead of "V__true"
** convention in cicada-nymph code
   * using dash to compose big word from small words
   * using "," as prefix and postfix separator
   * indentation style = free
   * words are separated by space
     except for bar-ket
     every bar-ket is viewed as a word
** syntax of cicada-nymph
   * syntax &  semantic
     | syntax          | semantic                  |
     |-----------------+---------------------------|
     | borderfix "* *" | variable                  |
     | borderfix "+ +" | [maybe use]               |
     | bar-ket ( )     | not use                   |
     | bar-ket [ ]     | not use                   |
     | bar-ket { }     | macro call                |
     |                 | (for macros of which      |
     |                 | the number of             |
     |                 | arguments is not fix)     |
     | double-quote    | viewed as special bar-ket |
     |                 | (bar is the same as ket)  |
     |                 | to support string literal |
     | prefix "!"      | exception                 |
     | postfix "!"     | some of the side-effect   |
     | postfix "?"     | predicate                 |
   * but I use
     1. "true" instead of "*true*"
     2. "false" instead of "*false*"
** unique id
   * if one wish to get a named unique id
     a jo maybe used
     for a jo is an address in memory
     it is unique as a memory address
   * but there is not effort made
     to distinguish address and fixnum
     as different type of things
     thus
     this kind of unique id is not fit
     for some tasks
* -----------------------------------
* note different from the re-designed cicada-language
   * simplifications are for teaching purpose only
   * first and foremost
     function programming will NOT be supported in this implementation
   * a helper function must be defined before it is used
   * no mixfix-notation
     * function call is "function" instead of "(function)"
     * no such thing like
       1 2 (add) = 1 (add 2) = (add 1 2)
   * no named local argument
     * thus no inited local argument
   * no title-name-table
     * thus in this implementation
       we only use single name space
     * thus in this implementation
       we do NOT have the concept of "context"
       so
       the syntax is not as flexible as it will be in cicada-language
   * no type
     * no type inference
     * no dynamic type tag
     * no static type declaration
   * global linked-list for naming
     * not hash-table
     * by the way
       in classical forth
       the linked-list of jo is called dictionary
   * no dynamic-memory-management
     * no garbage-collector
   * about comment
     * the comment of the argument & return value of function
       is allowed to be written in free style normal comment
* ===================================
* prolog
** ----------------------------------
** choose your platform
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;;;; before you compile the code
   ;;;; do not forget to choose your platform
   ;;;; in the following code

   linux? equ yes
   windows? equ no
   #+end_src
** misc
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate

   ;; in fasm, "end" is a reserved word
   finish equ end
   end equ exit
   #+end_src
** ----------------------------------
** header [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   define sys_6_r8  r8
   define sys_5_r9  r9
   define sys_4_r10 r10
   define sys_3_rdx rdx
   define sys_2_rsi rsi
   define sys_1_rdi rdi
   define sys_n_rax rax

   ;; the only three linux syscall we will use
   define syscall_read  0
   define syscall_write 1
   define syscall_exit  60

   finish if
   #+end_src
** format header [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   format elf64 executable 3

   finish if
   #+end_src
** entry [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   entry begin_to_interpret_threaded_code
   segment readable executable writeable

   finish if
   #+end_src
** ----------------------------------
** header [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   define fun_4_r9  r9
   define fun_3_r8  r8
   define fun_2_rdx rdx
   define fun_1_rcx rcx

   define STD_INPUT_HANDLE  -10
   define STD_OUTPUT_HANDLE -11

   finish if
   #+end_src
** format header [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   format PE64 console

   finish if
   #+end_src
** entry [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   entry begin_to_interpret_threaded_code
   section '.text' code writeable readable executable

   finish if
   #+end_src
** ----------------------------------
* -----------------------------------
* macro in assembly code
** jo_size
   * 64-bits
   * note that how "xx" is used as "dq" in a 64-bits version implementation
     when one wishs to port the implementation to 32-bits machine
     just use "xx equ dd"
   #+begin_src fasm :tangle cicada-nymph.fasm
   jo_size = 8 ;; (byte)
   xx equ dq
   #+end_src
** argument_stack & return_stack
   * when doing "push"
     a stack-pointer moves to lower address
   * note that another style is that
     when doing "push"
     a stack-pointer moves to higher address
   * the stack-pointer
     always stores the address of current-free-address of the stack
   * note that another style is that
     under the stack-pointer
     there always stores the value of the-top-of-the-stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   ;; =================================
   define pointer$argument_stack   r15
   define pointer$return_stack     r14
   ;; =================================

   macro push_argument_stack register {
      mov [pointer$argument_stack], register
      add pointer$argument_stack, jo_size
      }
   macro pop_argument_stack register {
      sub pointer$argument_stack, jo_size
      mov register, [pointer$argument_stack]
      }

   macro push_return_stack register {
      mov [pointer$return_stack], register
      add pointer$return_stack, jo_size
      }
   macro pop_return_stack register {
      sub pointer$return_stack, jo_size
      mov register, [pointer$return_stack]
      }
   #+end_src
** memory allocation in un_initialized_memory
   * implemented as a memory map
   #+begin_src fasm :tangle cicada-nymph.fasm
   current_free_address$un_initialized_memory = address$un_initialized_memory

   labeling  equ = current_free_address$un_initialized_memory
   preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
   #+end_src
** next
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro next {
      pop_return_stack rbx
        mov rax, qword [rbx]
      add rbx, jo_size
      push_return_stack rbx
        jmp qword [rax]
   }
   #+end_src
** note play with jo & jojo
   1. at the beginning
      * argument-stack
        << 2 >>
      * return-stack
        #+begin_src return-stack
        - [ (square) ]
            (square)
            (end)
        #+end_src
   2. next
      * argument-stack
        << 2 >>
      * return-stack
        #+begin_src return-stack
            (square)
        - [ (square) ] - [ (dup) ]
            (end)          (multiple)
                           (end)
        #+end_src
   3. next
      * argument-stack
        << 2, 2 >>
      * return-stack
        #+begin_src return-stack
            (square)       (dup)
        - [ (square) ] - [ (multiple) ]
            (end)          (end)
        #+end_src
   4. next
      * argument-stack << 4 >>
      * return-stack
        #+begin_src return-stack
                           (dup)
            (square)       (multiple)
        - [ (square) ] - [ (end) ]
            (end)
        #+end_src
   5. next
      * argument-stack << 4 >>
      * return-stack
        #+begin_src return-stack
            (square)
            (square)
        - [ (end) ] - [ (dup) ]
                        (multiple)
                        (end)
        #+end_src
   6. next
      * argument-stack
        << 4, 4 >>
      * return-stack
        #+begin_src return-stack
            (square)
            (square)    (dup)
        - [ (end) ] - [ (multiple) ]
                        (end)
        #+end_src
   7. next
      * argument-stack
        << 16 >>
      * return-stack
        #+begin_src return-stack
            (square)    (dup)
            (square)    (multiple)
        - [ (end) ] - [ (end) ]
        #+end_src
   8. next
      * argument-stack
        << 16 >>
      * return-stack
        #+begin_src return-stack
            (square)
            (square)
        - [ (end) ]
        #+end_src
   9. next
      * argument-stack
        << 16 >>
      * return-stack
        #+begin_src return-stack
        - [  ]
        #+end_src
   10. it is really simple
       ^-^
       is it not ?
* -----------------------------------
* helper function in assembly code
** ----------------------------------
** __exit_with_TOS [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   __exit_with_TOS:
      pop_argument_stack sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall

   finish if
   #+end_src
** __exit_with_zero [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   __exit_with_zero:
      xor sys_1_rdi, sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall

   finish if
   #+end_src
** __exit_with_six [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   __exit_with_six:
      mov sys_1_rdi, 6
      mov sys_n_rax, syscall_exit
      syscall

   finish if
   #+end_src
** ----------------------------------
** note windows calling convention for x86-64
   * [[https://msdn.microsoft.com/en-us/library/ew5tede7%28v=vs.90%29.aspx][microsoft's web]]
   * if you respect the calling convention
     1. your functions will be able to call other functions
        which respect the calling convention
     2. your functions will be call-able by other functions
        which respect the calling convention
   * in our program
     1. we do NOT need to respect the calling convention
        to let our functions be call-able by other function
        which respect the calling convention
     2. we ONLY need to respect the calling convention
        to let our functions be able to call other functions
        which respect the calling convention
   * before a call to function in kernel
     you have to 16-byte aligne the stack
   * pass first 4 arguments by rcx rdx r8 r9
     pass other arguments by stack
   * you have to reserve 4 place for the first 4 arguments
     although you do not need to push them into stack
   * you have to reserve 4 place for the first 4 arguments
     even if the function you are calling
     only uses less then 4 arguments
   * the code I am using
     to handle windows calling convention
     is de-macro-lized and un-optimized
     this is for teaching purpose only
** __exit_with_TOS [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   __exit_with_TOS:
      number_of_arguments = 4
      push rbp
      mov rbp, rsp

      mov rax, rsp
      add rax, 8*number_of_arguments
      mov rbx, 1111b
      and rbx, rax

      sub rsp, 16
      add rsp, rbx

      sub rsp, 8*4
      pop_argument_stack fun_1_rcx
      call [ExitProcess]

      mov rsp, rbp
      pop rbp

   finish if
   #+end_src
** __exit_with_zero [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   __exit_with_zero:
      number_of_arguments = 4
      push rbp
      mov rbp, rsp

      mov rax, rsp
      add rax, 8*number_of_arguments
      mov rbx, 1111b
      and rbx, rax

      sub rsp, 16
      add rsp, rbx

      sub rsp, 8*4
      xor fun_1_rcx, fun_1_rcx
      call [ExitProcess]

      mov rsp, rbp
      pop rbp

   finish if
   #+end_src
** __exit_with_six [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   __exit_with_six:
      number_of_arguments = 4
      push rbp
      mov rbp, rsp

      mov rax, rsp
      add rax, 8*number_of_arguments
      mov rbx, 1111b
      and rbx, rax

      sub rsp, 16
      add rsp, rbx

      sub rsp, 8*4
      mov fun_1_rcx, 15
      call [ExitProcess]

      mov rsp, rbp
      pop rbp

   finish if
   #+end_src
** ----------------------------------
* -----------------------------------
* macro for jo & explainer
** ----------------------------------
** link
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; initial link to point to 0 (as null)
   link = 0
   #+end_src
** primitive_string_heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$primitive_string_heap = 100 * 1024 ;; (byte)

   address$primitive_string_heap:
      times size$primitive_string_heap db 0

   current_free_address$primitive_string_heap = address$primitive_string_heap
   #+end_src
** make_primitive_string
   * 2 bytes for length of name_string
   * note that
     the following is using local label
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro make_primitive_string string {

   virtual at 0
   .start$string:
      db string
   .end$string:
      dw (.end$string - .start$string)
      load .length word from (.end$string)
   finish virtual
   store word .length at (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

   repeat .length
      virtual at 0
         db string
         load .char byte from (% - 1)
      finish virtual
      store byte .char at (current_free_address$primitive_string_heap)
      current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
   finish repeat

   }
   #+end_src
** ----------------------------------
** note
   * note that
     after a "next" "jmp" to a explainer
     the "rax" stores the value of the jo to be explained
     so
     "rax" is used as an inexplicit argument
     of the following functions
   * explain$function is used as jojo-head
     and explains the meaning of the jojo as function
   * a jojo-head identifies one type of jo
** define_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_function string, jo {

   define_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$function

      ;; here follows a jojo as function-body

      }
   #+end_src
** explain$function
   * find a jojo from a function-jo
     and push the jojo to return-stack
   * a jojo can not be of size 0
   * use rax as an argument
     which stores a jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$function:
      add rax, jo_size
      push_return_stack rax
      next
   #+end_src
** ----------------------------------
** note
   * primitive functions are special
     they explain themself
     and their type is not identified by jojo-head
** define_primitive_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_primitive_function string, jo {

   define_primitive_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx assembly_code__#jo

   assembly_code__#jo:

      ;; here follows assembly code
      ;; as primitive function body

      }
   #+end_src
** ----------------------------------
** note
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
** define_variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_variable string, jo {

   define_variable__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$variable

      ;; here follows a value of jo_size
      ;; only one value is allowed

      }
   #+end_src
** explain$variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$variable:
      add rax, jo_size
      mov rbx, [rax]
      push_argument_stack rbx
      next
   #+end_src
** ----------------------------------
* macro for make-jojo
** ----------------------------------
** note
   * the same as function
     we need to redefine it
     for the value of explainer
     is used to decide the type of the jo
** define_macro
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_macro string, jo {

   define_macro__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$macro

      ;; here follows a jojo as function-body

      }
   #+end_src
** explain$macro
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$macro:
      add rax, jo_size
      push_return_stack rax
      next
   #+end_src
** ----------------------------------
** note
   * explain$exception will
     1. search the return-stack for that exception
     2. special side-effect on return-stack
        to do exception handling
** define_exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_exception string, jo {

   define_exception__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$exception

      ;; here follows a jojo as function-body

      }
   #+end_src
** note return-stack in action
   1. when "explain$exception" is called
      jojo by jojo
      it searchs the jo stored in "rax" in the return-stack
      of course
      only jojo with "exception_head" as head needs to be searched
   2. for example
      we have
      #+begin_src fasm
      define_exception "!exception-1", !exception_1
         xx fun1
         xx fun2
         xx end
      #+end_src
   3. return-stack
      #+begin_src return-stack
                                               (prepare_for)
                                                 (exception_head)
                                                 (!exception_1)
                                                 (!exception_2)
                                                 (end_of_prepare)
                      (prepare_for)            (function_1)
      - [ pointer ] - [ (exception_head) ] - [ (function_2) ] - [ (!exception_1) ]
                        (!exception_1)         (end)              (end)
                        (!exception_2)
                        (end_of_prepare)
                      (function_1)
                      (function_2)
                      (end)

      the pointer above is into argument-stack
      #+end_src
   4. next
      * pointer$argument_stack
        should be set to the pointer above
      * and
        to call "next" again
        the return-stack should be change to
        #+begin_src return-stack
        - [ (fun1) ]
            (fun2)
            (end)
        #+end_src
** note the plan
   * so
     we need a two-level loop
   * note that
     although
     we have to use assembly code
     to write primitive functions
     but
     we still can use argument-stack
     to pass arguments
** explain$exception
   * no error handling for now
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$exception:
      mov rsi, rax

   .next_jojo:
      pop_return_stack rbx
      mov rax, qword [rbx]
      cmp rax, exception_head
      je .next_jo
      cmp pointer$return_stack, address$return_stack
      je .not_found
      jmp .next_jojo


   .next_jo:
      ;; expecting
      ;;   rbx jojo
      ;;   rsi jo (to cmp)
      add rbx, jo_size
      mov rax, qword [rbx]
      cmp rax, rsi
      je .found
      test rax, rax
      jz .next_jojo
      jmp .next_jo


   .found:
      ;; expecting
      ;;   pointer$return_stack
      ;;   rsi jo
      pop_return_stack rax
      mov pointer$argument_stack, rax
      add rsi, jo_size
      push_return_stack rsi
      next

   .not_found:
      call __exit_with_six
   #+end_src
** ----------------------------------
* execute-jo & structure of jo
** ----------------------------------
** execute-jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- unknown >>
      pop_argument_stack rax
      jmp qword [rax]
   #+end_src
** ----------------------------------
** *jo-size*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*jo-size*", V__jo_size
      xx 8
   #+end_src
** jo->name
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->name", jo_to_name
      ;; << jo -- string[address, length] >>
      xx literal, jo_size, subtraction
      xx literal, jo_size, subtraction
      xx fetch
      xx dup
      xx   literal, 2, addition, swap
      xx fetch_two_bytes
      xx end
   #+end_src
** jo->link
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->link", jo_to_link
      ;; << jo -- link >>
      xx literal, jo_size
      xx subtraction
      xx end
   #+end_src
** last-jo,dictionary?
   * first jo in assembly code
     is the last jo in dictionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "last-jo,dictionary?", last_jo__dictionary?
      ;; << jo -- bool >>
      xx jo_to_link
      xx fetch
      xx zero?
      xx end
   #+end_src
** jo->pre-jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->pre-jo", jo_to_pre_jo
      ;; << jo -- pre-jo >>
      xx jo_to_link
      xx fetch
      xx literal, jo_size
      xx addition
      xx end
   #+end_src
** jo->type
   * the type of primitive function jo
     is encoded by 0
   * other types of jo
     are encoded by their explainers
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->type", jo_to_type
      ;; << jo -- type >>
      xx dup

      xx dup, fetch
      xx swap, subtraction, literal, 8, equal?, false?branch, 4
      xx   drop, zero
      xx   end

      xx fetch
      xx end
   #+end_src
** ----------------------------------
* type of jo
** primitive-function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "primitive-function-jo?", primitive_function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx zero?
      xx end
   #+end_src
** function-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "function-jo?", function_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$function
      xx equal?
      xx end
   #+end_src
** macro-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "macro-jo?", macro_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$macro
      xx equal?
      xx end
   #+end_src
** exception-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "exception-jo?", exception_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$exception
      xx equal?
      xx end
   #+end_src
** variable-jo?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "variable-jo?", variable_jo?
      ;; << jo -- bool >>
      xx jo_to_type
      xx literal, explain$variable
      xx equal?
      xx end
   #+end_src
* -----------------------------------
* end & taca
** end
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "end", end
      pop_return_stack rbx
      next
   #+end_src
** taca
   * tail-call
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "<>", taca
      pop_return_stack rbx
      mov rax, qword [rbx]
      jmp qword [rax]
   #+end_src
** note explicit tail call in action
   1. the tail position of a function body must be recognized
      explicit tail call is used to achieve this
   2. thus
      tail-recursive-call can be use to do loop
      without pushing too many address into return-stack
   3. for example if we have a function
      which is called "example"
      #+begin_src fasm
      define_function "example", example
         xx fun1
         xx fun2
         xx taca, example
      #+end_src
   4. and we have the following jojo in return-stack
      #+begin_src return-stack
      - [ (example) ]
          (end)
      #+end_src
   5. next
      #+begin_src return-stack
          (example)
      - [ (end) ] - [ (fun1) ]
                      (fun2)
                      (taca)
                      (example)
      #+end_src
   6. next
      #+begin_src return-stack
          (example)   (fun1)
      - [ (end) ] - [ (fun2) ]
                      (taca)
                      (example)
      #+end_src
   7. next
      #+begin_src return-stack
                      (fun1)
          (example)   (fun2)
      - [ (end) ] - [ (taca) ]
                      (example)
      #+end_src
   8. next
      by the definition of taca
      #+begin_src return-stack
          (example)
      - [ (end) ] - [ (fun1) ]
                      (fun2)
                      (taca)
                      (example)
      #+end_src
   9. you can see return-stack of (8.)
      is the same as (5.)
      it is clear how the example function
      is actually a loop now
* -----------------------------------
* *the story begin*
** begin_to_interpret_threaded_code [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   begin_to_interpret_threaded_code:

      cld ;; set DF = 0, then rsi and rdi are incremented

      mov pointer$argument_stack,  address$argument_stack
      mov pointer$return_stack,    address$return_stack

      mov rax, first_jojo
      push_return_stack rax
      next

   finish if
   #+end_src
** begin_to_interpret_threaded_code [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   ;;;; for windows
   _output_handle:
      dq 0
   _input_handle:
      dq 0
   ;;;;

   begin_to_interpret_threaded_code:

      cld ;; set DF = 0, then rsi and rdi are incremented


      ;;;; for windows
      number_of_arguments = 4
      push rbp
      mov rbp, rsp
      mov rax, rsp
      add rax, 8*number_of_arguments

      mov rbx, 1111b
      and rbx, rax

      sub rsp, 16
      add rsp, rbx


      sub rsp, 8*4
      mov fun_1_rcx, STD_INPUT_HANDLE
      call [GetStdHandle]
      mov [_input_handle], rax


      mov rsp, rbp
      pop rbp



      number_of_arguments = 4
      push rbp
      mov rbp, rsp

      mov rax, rsp
      add rax, 8*number_of_arguments
      mov rbx, 1111b
      and rbx, rax

      sub rsp, 16
      add rsp, rbx

      sub rsp, 8*4
      mov fun_1_rcx, STD_OUTPUT_HANDLE
      call [GetStdHandle]
      mov [_output_handle], rax

      mov rsp, rbp
      pop rbp
      ;;;;


      mov pointer$argument_stack,  address$argument_stack
      mov pointer$return_stack,    address$return_stack

      mov rax, first_jojo
      push_return_stack rax
      next

   finish if
   #+end_src
** first_jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   first_jojo:
      xx basic_REPL

      ;; you can use comment out "xx basic_REPL"
      ;; and use the following "xx little_test"
      ;; to do some little tests
      ;; by set up the code block beneath
      ;;    define_function "little_test", little_test

      ;; xx little_test
   #+end_src
** exit_with_TOS a.k.a. bye
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bye", exit_with_TOS
      call __exit_with_TOS
   #+end_src
** little_test
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "", V__little_test_number
      xx 3


   define_function "little_test", little_test

      ;;;; variable
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; 3

      ;;;; literal
      ;; xx literal, 4
      ;; xx exit_with_TOS
      ;;;; 4

      ;;;; address
      ;; xx address, V__little_test_number, fetch, add2
      ;; xx address, V__little_test_number, save
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; 5

      ;;;; write_byte
      ;; xx literal, 64, write_byte
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; @

      ;;;; read_byte
      ;; xx read_byte, write_byte
      ;; xx exit_with_TOS
      ;;;;

      ;;;; branch
      ;; xx read_byte, write_byte
      ;; xx branch, -3
      ;;;; read a string that ended by <return>
      ;;;; write the readed string
      ;;;; or we can say
      ;;;; read line and write line
      ;;;; or we can say
      ;;;; echo line

      ;;;; false?branch
      ;; xx V__false, false?branch, 9
      ;; xx   literal, 64, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx V__true, false?branch, 9
      ;; xx   literal, 65, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; A

      ;;;; read_word & write_string
      ;; xx read_word, write_string
      ;; xx literal, 10, write_byte
      ;; xx read_word_for_REPL, write_string
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; read line
      ;;;; write first two words of the line

      ;;;; string->integer
      ;; xx read_word, string_to_integer
      ;; xx exit_with_TOS
      ;;;; type 123
      ;;;; exit code 123

      ;;;; use jo_to_name to test the macro make_primitive_string
      ;; xx literal, jo_to_name, jo_to_name, write_string
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; print "jo->name"

      ;;;; basic-REPL (without the ability to define function)
      ;;;; after this test
      ;;;; we will use basic-REPL to do further tests
      xx basic_REPL
      ;;;; 1 2 add .
   #+end_src
* -----------------------------------
* argument_stack
** memory allocation
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve 64 * jo_size
   address$argument_stack labeling
      preserve 1024 * 1024 * jo_size
   #+end_src
** drop
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "drop", drop
      ;; << a -- >>
      pop_argument_stack rax
      next

   define_primitive_function "drop2", drop2
      ;; << a b -- >>
      pop_argument_stack rax
      pop_argument_stack rax
      next
   #+end_src
** dup
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "dup", dup
      ;; << a -- a a >>
      mov  rax, [pointer$argument_stack - (1 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "dup2", dup2
      ;; << a b -- a b a b >>
      mov  rbx, [pointer$argument_stack - (1 * jo_size)]
      mov  rax, [pointer$argument_stack - (2 * jo_size)]
      push_argument_stack rax
      push_argument_stack rbx
      next
   #+end_src
** over
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "over", over
      ;; << a b -- a b | a >>
      mov  rax, [pointer$argument_stack - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xx", xoverxx
      ;; << a | b c -- a | b c | a >>
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|x", xxoverx
      ;; << a b | c -- a b | c | a b >>
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xx", xxoverxx
      ;; << a b | c d -- a b | c d | a b >>
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxx", xoverxxx
      ;; << a | b c d -- a | b c d | a >>
      mov  rax, [pointer$argument_stack - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xxxx", xxoverxxxx
      ;; << a b | c d e f -- a b | c d e f | a b >>
      mov  rax, [pointer$argument_stack - (6 * jo_size)]
      push_argument_stack rax
      mov  rax, [pointer$argument_stack - (6 * jo_size)]
      push_argument_stack rax
      next
   #+end_src
** tuck
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "tuck", tuck
      ;; << a b -- b | a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|tuck|xx", xtuckxx
      ;; << a | b c -- b c | a | b c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|x", xxtuckx
      ;; << a b | c -- c | a b | c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|xx", xxtuckxx
      ;; << a b | c d -- c d | a b | c d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next

   define_primitive_function "xxx|tuck|x", xxxtuckx
      ;; << a b c | d -- d | a b c | d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next
   #+end_src
** swap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "swap", swap
      ;; << a b -- b a >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      next

   define_primitive_function "x|swap|xx", xswapxx
      ;; << a | b c -- b c | a >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      next

   define_primitive_function "xx|swap|x", xxswapx
      ;; << a b | c -- c | a b >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|swap|xxx", xswapxxx
      ;; << a | b c d -- b c d | a >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      next

   define_primitive_function "xxx|swap|x", xxxswapx
      ;; << a b c | d -- d | a b c >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|swap|xx", xxswapxx
      ;; << a b | c d -- c d | a b >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      next


   define_primitive_function "x|swap|xxxx", xswapxxxx
      ;; << a | b c d e -- b c d e | a >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack rax
      next

   define_primitive_function "xxxx|swap|x", xxxxswapx
      ;; << a b c d | e --  e | a b c d >>
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next


   define_primitive_function "xx|swap|xxxx", xxswapxxxx
      ;; << a b | c d e f -- c d e f | a b >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "xxxx|swap|xx", xxxxswapxx
      ;; << a b c d | e f --  e f | a b c d >>
      pop_argument_stack r9 ;; f
      pop_argument_stack r8 ;; e
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack r8 ;; e
      push_argument_stack r9 ;; f
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next
   #+end_src
* return_stack
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve 64 * jo_size
   address$return_stack labeling
      preserve 1024 * 1024 * jo_size
   #+end_src
* instruction
** ----------------------------------
** note side-effect
   * an instruction
     is a special primitive function
     which does special side-effect on return-stack
   * note that
     side-effect on return-stack
     should all be done in primitive functions
** note naming
   * the naming convention in assembly code
     of instruction
     is the same as it of jo
   * the name of an instruction
     might not be exported to cicada-language as a function
     but as a variable
   * the name of a special primitive function in assembly code
     maybe reused as a macro word in cicada-language
     but the name of the macro in assembly code
     is prefixed by "M__"
** ----------------------------------
** literal
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*literal*", V__literal
      xx literal

   define_primitive_function "", literal
      ;; << -- fixnum >>
      pop_return_stack rbx
        mov rax, [rbx]
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*address*", V__address
      xx address

   define_primitive_function "", address
      ;; << -- address >>
      pop_return_stack rbx
        mov rax, [rbx]
        add rax, jo_size
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
** branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*branch*", V__branch
      xx branch

   define_primitive_function "", branch
      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next
   #+end_src
** false?branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*false?branch*", V__false?branch
      xx false?branch

   define_primitive_function "", false?branch
      ;; << true of false -- >>
      pop_argument_stack rax
      test rax, rax
      jnz help__false?branch__not_to_branch

      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next

   help__false?branch__not_to_branch:
      pop_return_stack rbx
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
** note return-stack in action
   1. proper exception handling
      is implemented by doing side-effect on return-stack
   2. when executing the following code block
      #+begin_src fasm
      xx prepare_for
      xx exception_head
      xx   !exception_1
      xx   !exception_2
      xx   end_of_prepare
      xx function_1
      xx function_2
      xx ><><>< end
      #+end_src
   3. return-stack
      #+begin_src return-stack
      - [ (prepare_for) ]
            (exception_head)
            (!exception_1)
            (!exception_2)
            (end_of_prepare)
          (function_1)
          (function_2)
          (end)
      #+end_src
   4. next
      * this is how the return-stack looks
        right before exception_head is executed
        #+begin_src return-stack
          (prepare_for)
        - [ (exception_head) ]
            (!exception_1)
            (!exception_2)
            (end_of_prepare)
          (function_1)
          (function_2)
          (end)
        #+end_src
      * after exception_head is executed
        #+begin_src return-stack
                                                 (prepare_for)
                                                   (exception_head)
                                                   (!exception_1)
                                                   (!exception_2)
                        (prepare_for)              (end_of_prepare)
        - [ pointer ] - [ (exception_head) ] - [ (function_1) ]
                          (!exception_1)         (function_2)
                          (!exception_2)         (end)
                          (end_of_prepare)
                        (function_1)
                        (function_2)
                        (end)

        the pointer above is into argument-stack
        #+end_src
** prepare_for
   * prepare for a list of exceptions
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", prepare_for
      ;; << -- >>
      pop_return_stack rbx
      push_return_stack pointer$argument_stack
      push_return_stack rbx
   .next:
      add rbx, jo_size
      mov rax, qword [rbx]
      cmp rax, end_of_prepare
      je .then
      jmp .next
   .then:
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** end_of_prepare
   * used as an unique id
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*end-of-prepare*", V__end_of_prepare

   end_of_prepare:
      xx 0
   #+end_src
** exception_head
   * this jo is served as a label in return-stack
     when explained
     it pops the jojo itself in
     and
     it pops the argument-stack pointer after it
   * and "explain$exception" will search for them
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "", exception_head
      ;; << -- >>
      pop_return_stack rax
      pop_return_stack rax
      next
   #+end_src
** ----------------------------------
* bool
** false & true
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "false", false
      ;; << -- false >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "true", true
      ;; << -- true >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** false? & true?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "false?", false?
      ;; << bool -- bool >>
      xx false, equal?
      xx end

   define_function "true?", true?
      ;; << bool -- bool >>
      xx true, equal?
      xx end
   #+end_src
** bitwise operations
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bitwise-and", bitwise_and
      ;; << a, b -- a and b >>
      pop_argument_stack rbx
      and [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-or", bitwise_or
      ;; << a, b -- a or b >>
      pop_argument_stack rbx
      or  [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-xor", bitwise_xor
      ;; << a, b -- a xor b >>
      pop_argument_stack rbx
      xor [pointer$argument_stack - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-invert", bitwise_invert
      ;; << a -- invert a >>
      not qword [pointer$argument_stack - (1 * jo_size)]
      next
   #+end_src
* fixnum
** zero & one
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "zero", zero
      ;; << -- 0 >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "one", one
      ;; << -- 1 >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** zero? & one?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero?", zero?
      ;; << bool -- bool >>
      xx zero, equal?
      xx end

   define_function "one?", one?
      ;; << bool -- bool >>
      xx one, equal?
      xx end
   #+end_src
** add & sub & mul & div & mod & negate & power
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "add1", add1
      ;; << n -- n+1 >>
      inc qword [pointer$argument_stack - (1 * jo_size)]
      next

   define_primitive_function "add2", add2
      ;; << n -- n+2 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 2
      next

   define_primitive_function "add3", add3
      ;; << n -- n+3 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 3
      next

   define_primitive_function "add4", add4
      ;; << n -- n+4 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 4
      next

   define_primitive_function "add8", add8
      ;; << n -- n+8 >>
      add qword [pointer$argument_stack - (1 * jo_size)], 8
      next


   define_primitive_function "sub1", sub1
      ;; << n -- n-1 >>
      dec qword [pointer$argument_stack - (1 * jo_size)]
      next

   define_primitive_function "sub2", sub2
      ;; << n -- n-2 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 2
      next

   define_primitive_function "sub3", sub3
      ;; << n -- n-3 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 3
      next

   define_primitive_function "sub4", sub4
      ;; << n -- n-4 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 4
      next

   define_primitive_function "sub8", sub8
      ;; << n -- n-8 >>
      sub qword [pointer$argument_stack - (1 * jo_size)], 8
      next


   define_primitive_function "add", addition
      ;; << a b -- a+b >>
      pop_argument_stack rax
      add qword [pointer$argument_stack - (1 * jo_size)], rax
      next

   define_primitive_function "sub", subtraction
      ;; << a b -- a-b >>
      pop_argument_stack rax
      sub qword [pointer$argument_stack - (1 * jo_size)], rax
      next

   define_primitive_function "mul", multiple
      ;; << a b -- a*b >>
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      imul rbx, rax
      ;; imul will ignore overflow
      ;; when there are two registers as arg
      ;; imul will save the result into the first register
      push_argument_stack rbx
      next

   define_primitive_function "moddiv", moddiv
      ;; << a, b -- a mod b, quotient >>
      ;; << dividend, divisor -- remainder, quotient >>
      ;; the arg of idiv is divisor
      ;; the lower half of dividend is taken from rax
      ;; the upper half of dividend is taken from rdx
      xor  rdx, rdx   ;; high-part of dividend is not used
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      idiv rbx
      ;; the remainder is stored in rdx
      ;; the quotient  is stored in rax
      push_argument_stack rdx ;; remainder
      push_argument_stack rax ;; quotient
      next


   define_function "divmod", divmod
      ;; << a, b -- quotient, a mod b >>
      xx moddiv, swap
      xx end

   define_function "div", division
      ;; << a, b -- quotient >>
      xx divmod, drop
      xx end

   define_function "mod", modulo
      ;; << a, b -- a mod b >>
      xx moddiv, drop
      xx end

   define_function "negate", negate
      ;; << n --  -n >>
      xx zero
      xx swap, subtraction
      xx end


   define_function "power", power
      ;; n must be nature number for now
      ;; << a, n -- a^n >>
      xx literal, 1, swap ;; leave product
      xx help__power
      xx end

   define_function "help,power", help__power
      ;; << a, product, n -- a^n >>
      xx dup, zero?, false?branch, 5
      xx   drop, swap, drop
      xx   end
      xx sub1
      xx swap
      xx   xoverxx, multiple
      xx swap
      xx taca, help__power
   #+end_src
** equal & greater-than & less-than
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "equal?", equal?
      ;; << a, b -- a, b, true of false >>
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rbx, rax
      sete  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "less-than?", less_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setl  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-than?", greater_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setg  al
      movzx rax, al
      push_argument_stack  rax
      next

   define_primitive_function "less-or-equal?", less_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setle al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-or-equal?", greater_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setge al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** negative? & positive?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negative?", negative?
      ;; << integer -- bool >>
      xx zero, less_than?
      xx end

   define_function "positive?", positive?
      ;; << integer -- bool >>
      xx negative?, false?
      xx end
   #+end_src
* memory
  * although the following functions are all side-effect
    but I use "save" instead of "save!"
  #+begin_src fasm :tangle cicada-nymph.fasm
  ;; "save" and "fetch" default to a jo_size
  ;; the rule of "fetch2" and so on are:
  ;;   in memory:
  ;;     ||  1 : value-1  ||
  ;;     ||  1 : value-2  ||
  ;;     ||  1 : value-3  ||
  ;;     ...
  ;;   on stack:
  ;;     << value-1, value-2, value-3, ... >>
  ;; of course we have:
  ;;   fetch2 : memory=copy=>stack
  ;;   save2  : stack->memory

  define_primitive_function "save", save
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov qword [rbx], rax
     next

  define_primitive_function "save-byte", save_byte
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov byte[rbx], al
     next

  define_primitive_function "save-two-bytes", save_two_bytes
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov word [rbx], ax
     next

  define_primitive_function "save-four-bytes", save_four_bytes
     ;; ( value, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     mov dword [rbx], eax
     next

  define_primitive_function "n-save", n_save
     ;; << value-n, ..., value-1, address, n -- >>
     pop_argument_stack rcx
     pop_argument_stack rdx
     mov rax, jo_size
     imul rax, rcx
     add rdx, rax
     ;; for address is based on 0
     ;; but n is based on 1
     sub rdx, jo_size
  .loop:
     pop_argument_stack rax
     mov qword [rdx], rax
     sub rdx, jo_size
     loop .loop
     next

  define_function "save2", save2
     ;; << value-2, value-1, address -- >>
     xx literal, 2
     xx n_save
     xx end

  define_primitive_function "n-save-byte", n_save_byte
     ;; << value-n, ..., value-1, address, n -- >>
     pop_argument_stack rcx
     pop_argument_stack rdx
     add rdx, rcx
     dec rdx
  .loop:
     pop_argument_stack rax
     mov byte [rdx], al
     dec rdx
     loop .loop
     next

  define_primitive_function "fetch", fetch
     ;; ( address -- value )
     pop_argument_stack  rbx
     mov rax, qword [rbx]
     push_argument_stack rax
     next

  define_primitive_function "fetch-byte", fetch_byte
     ;; ( address -- value )
     pop_argument_stack rbx
     xor rax, rax
     mov al, byte[rbx]
     push_argument_stack rax
     next

  define_primitive_function "fetch-two-bytes", fetch_two_bytes
     ;; ( address -- value )
     pop_argument_stack rbx
     xor rax, rax
     mov ax, word [rbx]
     push_argument_stack rax
     next

  define_primitive_function "fetch-four-bytes", fetch_four_bytes
     ;; ( address -- value )
     pop_argument_stack rbx
     xor rax, rax
     mov eax, dword [rbx]
     push_argument_stack rax
     next

  ;;   in memory:
  ;;     ||  1 : value-1  ||
  ;;     ...
  ;;     ||  1 : value-n  ||
  define_primitive_function "n-fetch", n_fetch
     ;; << address, n -- value-1, ..., value-n >>
     pop_argument_stack  rcx
     pop_argument_stack  rdx
  .loop:
     mov rax, qword [rdx]
     push_argument_stack rax
     add rdx, jo_size
     loop .loop
     next

  define_primitive_function "n-fetch-byte", n_fetch_byte
     ;; << address, n -- byte-1, ..., byte-n >>
     pop_argument_stack  rcx
     pop_argument_stack  rdx
     xor rax, rax
  .loop:
     mov al, byte [rdx]
     push_argument_stack rax
     inc rdx
     loop .loop
     next

  define_function "fetch2", fetch2
     ;; << address -- value-1, value-2 >>
     xx literal, 2
     xx n_fetch
     xx end

  define_primitive_function "add-save", add_save
     ;; ( number to add, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     add qword [rbx], rax
     next

  define_primitive_function "sub-save", sub_save
     ;; ( number to add, address -- )
     pop_argument_stack rbx
     pop_argument_stack rax
     sub qword [rbx], rax
     next
  #+end_src
* basic io
** ----------------------------------
** note byte
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_input_length = 1024 * 1024

   buffer$read_byte labeling
      preserve max_input_length
   #+end_src
** write-byte [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   buffer$write_byte:
      db 0

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      ;; just calls the Linux write system call
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al

      ;;;; for linux
      mov sys_3_rdx, 1                 ;; max length to be write
      mov sys_2_rsi, buffer$write_byte ;; address
      mov sys_1_rdi, 1                 ;; stdout
      mov sys_n_rax, syscall_write
      ;;;;

      syscall
      next

   finish if
   #+end_src
** read-byte [linux]
   * calls the Linux read system call to fill buffer$read_byte
   * if it detects that stdin has closed
     it exits the program
     which is why when you hit C-d the system exits
   * add the teature to unread one ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   flag$unreaded_ket_char:
      xx 0

   char$unreaded_ket_char:
      xx 0

   define_function "have-unreaded-ket-char?", have_unreaded_ket_char?
      ;; << -- bool >>
      xx literal, flag$unreaded_ket_char
      xx fetch
      xx end

   define_function "unread-ket-char", unread_ket_char
      ;; << char -- >>
      xx literal, char$unreaded_ket_char, save
      xx true, literal, flag$unreaded_ket_char
      xx save
      xx end


   ;; help__read_byte is the old do function without unread ket-char
   define_function "read-byte", read_byte
      ;; << -- byte >>
      xx have_unreaded_ket_char?, false?branch, 9
      xx   literal, char$unreaded_ket_char, fetch_byte
      xx   zero, literal, flag$unreaded_ket_char
      xx   save
      xx   end
      xx help__read_byte
      xx end



   cursor$read_byte:
      xx 0

   border$read_byte:
      xx 0

   define_primitive_function "help,read-byte", help__read_byte
      ;; << -- byte >>
      call help__help__read_byte
      push_argument_stack rax
      next


   help__help__read_byte:
      mov rbx, [cursor$read_byte]
      cmp rbx, [border$read_byte]
      ;; [cursor$read_byte] <  [border$read_byte]
      jl .we_still_have_buffered_byte
      ;; [cursor$read_byte] >= [border$read_byte]
      jmp .do_a_new_buffer


   .do_a_new_buffer:
      mov rbx, buffer$read_byte
      mov [cursor$read_byte], rbx
      mov [border$read_byte], rbx

      ;;;; for linux
      mov sys_3_rdx, max_input_length ;; max length to be read
      mov sys_2_rsi, buffer$read_byte ;; buffer address
      xor sys_1_rdi, sys_1_rdi        ;; stdin
      mov sys_n_rax, syscall_read
      syscall
      ;; the return value of syscall read
      ;; is a count of the number of bytes transferred
      ;;;;

      ;; the following will let the interpreter exit
      ;; when meeting end-of-line or reading error
      test rax, rax
      jz .error ;; rax = 0
      js .error ;; rax < 0

      ;; update [border$read_byte]
      add [border$read_byte], rax
      jmp help__help__read_byte


   .we_still_have_buffered_byte:
      ;; for the following will just uses the al part of rax
      ;; it is necessary to clear rax
      xor rax, rax
      mov al, byte [rbx]
      inc rbx
      mov [cursor$read_byte], rbx
      ret


   .error:
      ;; exit with exit code = 0
      call __exit_with_zero

   finish if
   #+end_src
** ----------------------------------
** write-byte [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   buffer$write_byte:
      db 0

   ;;;; for windows
   _counter$write_byte:
      dq 0
   ;;;;

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      ;; just calls the Linux write system call
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al

      ;;;; for windows
      number_of_arguments = 5
      push rbp
      mov rbp, rsp

      mov rax, rsp
      add rax, 8*number_of_arguments
      mov rbx, 1111b
      and rbx, rax

      sub rsp, 16
      add rsp, rbx


      push 0
      sub rsp, 8*4
      mov fun_4_r9, _counter$write_byte
      mov fun_3_r8, 1
      mov fun_2_rdx, buffer$write_byte
      mov fun_1_rcx, [_output_handle]
      call [WriteFile]


      mov rsp, rbp
      pop rbp
      ;;;;

      next

   finish if
   #+end_src
** read-byte [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   flag$unreaded_ket_char:
      xx 0

   char$unreaded_ket_char:
      xx 0

   define_function "have-unreaded-ket-char?", have_unreaded_ket_char?
      ;; << -- bool >>
      xx literal, flag$unreaded_ket_char
      xx fetch
      xx end

   define_function "unread-ket-char", unread_ket_char
      ;; << char -- >>
      xx literal, char$unreaded_ket_char, save
      xx true, literal, flag$unreaded_ket_char
      xx save
      xx end


   ;; help__read_byte is the old do function without unread ket-char
   define_function "read-byte", read_byte
      ;; << -- byte >>
      xx have_unreaded_ket_char?, false?branch, 9
      xx   literal, char$unreaded_ket_char, fetch_byte
      xx   zero, literal, flag$unreaded_ket_char
      xx   save
      xx   end
      xx help__read_byte
      xx end

   ;;;; for windows
   _counter$read_byte:
      dq 0
   ;;;;

   cursor$read_byte:
      xx 0

   border$read_byte:
      xx 0

   define_primitive_function "help,read-byte", help__read_byte
      ;; << -- byte >>
      call help__help__read_byte
      push_argument_stack rax
      next


   help__help__read_byte:
      mov rbx, [cursor$read_byte]
      cmp rbx, [border$read_byte]
      ;; [cursor$read_byte] <  [border$read_byte]
      jl .we_still_have_buffered_byte
      ;; [cursor$read_byte] >= [border$read_byte]
      jmp .do_a_new_buffer


   .do_a_new_buffer:
      mov rbx, buffer$read_byte
      mov [cursor$read_byte], rbx
      mov [border$read_byte], rbx

      ;;;; for windows
      number_of_arguments = 5
      push rbp
      mov rbp, rsp

      mov rax, rsp
      add rax, 8*number_of_arguments
      mov rbx, 1111b
      and rbx, rax

      sub rsp, 16
      add rsp, rbx

      push 0
      sub rsp, 8*4
      mov fun_4_r9, _counter$read_byte
      mov fun_3_r8, max_input_length
      mov fun_2_rdx, buffer$read_byte
      mov fun_1_rcx, [_input_handle]
      call [ReadFile]

      mov rsp, rbp
      pop rbp
      ;;;;

      ;; the return value of syscall read
      ;; is a count of the number of bytes transferred

      ;;;; for windows
      mov rax, [_counter$read_byte]
      ;;;;

      ;; the following will let the interpreter exit
      ;; when meeting end-of-line or reading error
      test rax, rax
      jz .error ;; rax = 0
      js .error ;; rax < 0


      ;; update [border$read_byte]
      add [border$read_byte], rax
      jmp help__help__read_byte


   .we_still_have_buffered_byte:
      ;; for the following will just uses the al part of rax
      ;; it is necessary to clear rax
      xor rax, rax
      mov al, byte [rbx]
      inc rbx
      mov [cursor$read_byte], rbx
      ret


   .error:
      ;; exit with exit code = 0
      call __exit_with_zero


   finish if
   #+end_src
** ----------------------------------
* -----------------------------------
* char
** space-char?
   * as for space-char
     I only use two
     ASCII 10 (newline)
     ASCII 32 (whitespace)
   * note that
     I use the term "whitespace" to denotes the char
     I use the term "space" to denotes the set of chars
   * I will simply view number less-or-equal 32 as space-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-char?", space_char?
      ;; << char -- bool >>
      xx literal, 32
      xx less_or_equal?
      xx end
   #+end_src
** bar-ket-char?
   * () [] {}
     but not <>
   * double-quote is viewed as special bar-ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "bar-ket-char?", bar_ket_char?
      ;; << char -- bool >>
      xx dup, literal, '(', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ')', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '[', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ']', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '{', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '}', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '"', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** decimal-digital-char?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digital-char?", decimal_digital_char?
      ;; << char -- bool >>
      xx dup, literal, '0', less_than?, false?branch, 4
      xx   drop, false
      xx   end
      xx dup, literal, '9', less_or_equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** note digital
   * a decimal-digital is number from 0 to 9
   * a binary-digital is number from 0 to 1
** char->decimal-digital & decimal-digital->char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char->decimal-digital", char_to_decimal_digital
      ;; << char -- decimal-digital >>
      xx literal, '0'
      xx subtraction
      xx end

   define_function "decimal-digital->char", decimal_digital_to_char
      ;; << decimal-digital -- char >>
      xx literal, '0'
      xx addition
      xx end
   #+end_src
* buffer
** note
   * a buffer is a large vector
     and some functions do not care about how large it is
** compare-buffer
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; return false when length == 0
   define_primitive_function "compare-buffer", compare_buffer
      ;; << address, address, length -- bool >>
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      repe cmpsb
      sete al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
* string
** ----------------------------------
** note io about string
** write-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-string", write_string
      ;; << string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end
      xx sub1, swap
      xx dup, fetch_byte, write_byte
      xx add1, swap
      xx taca, write_string
   #+end_src
** pretty_write_string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function ".s", pretty_write_string
      ;; << integer -- >>
      xx write_string
      xx literal, 10
      xx write_byte
      xx end
   #+end_src
** ----------------------------------
** string-equal?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-equal?", string_equal?
      ;; << string[address, length], string[address, length] -- bool >>
      xx xoverxx, equal?, false?branch, 4
      xx   swap
      xx   compare_buffer
      xx   end
      xx drop, drop2
      xx false
      xx end
   #+end_src
** string-[head|tail],char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,char", string_head__char
      ;; << string[address, length] -- char >>
      xx drop, fetch_byte
      xx end

   define_function "string-tail,char", string_tail__char
      ;; << string[address, length] -- [address + 1, length + 1] >>
      xx sub1, swap
      xx add1
      xx swap
      xx end
   #+end_src
** string->buffer!
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "string->buffer!", string_to_buffer!
      ;; ( string[address, length], buffer[address] -- )
      pop_argument_stack rdi ;; destination
      pop_argument_stack rcx ;; counter
      pop_argument_stack rsi ;; source
      rep movsb
      next
   #+end_src
** string-reverse!
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rdi, buffer$string_reverse!
      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
      rep movsb

      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next
   #+end_src
** digital-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digital-string?", digital_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx over, fetch_byte, decimal_digital_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, digital_string?
      xx drop2, false
      xx end
   #+end_src
** char-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char-string?", char_string?
      ;; << string[address, length], char -- bool >>
      xx xxswapx
      xx dup, one?, false?, false?branch, 5
      xx   drop2, drop
      xx   false
      xx   end
      xx string_head__char, equal?, false?branch, 3
      xx   true
      xx   end
      xx false
      xx end
   #+end_src
** zero-string?
   * "0" or "-0"
     0 is special when compiling literal number
     for we are using 0 as "end"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero-string?", zero_string?
      ;; << string[address, length] -- bool >>
      xx dup2, literal, '0', char_string?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2
      xx string_head__char, literal, '-', equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx string_tail__char, literal, '0', char_string?
      xx end
   #+end_src
** integer-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "integer-string?", integer_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, literal, '-', char_string?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, string_head__char, literal, '-', equal?, false?branch, 4
      xx   string_tail__char
      xx   digital_string?
      xx   end
      xx digital_string?
      xx end
   #+end_src
** string->integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->integer", string_to_integer
      ;; << string[address, length] -- integer >>
      xx dup2, string_head__char, literal, '-', equal?, false?, false?branch, 3
      xx   digital_string_to_integer
      xx   end
      xx string_tail__char
      xx digital_string_to_integer
      xx negate
      xx end


   sum$digital_string_to_integer:
      xx 0

   counter$digital_string_to_integer:
      xx 0

   define_function "digital-string->integer", digital_string_to_integer
      ;; << string[address, length] -- integer >>
      xx zero, literal, sum$digital_string_to_integer, save
      xx zero, literal, counter$digital_string_to_integer, save

      xx dup2, string_reverse!
      xx   help__digital_string_to_integer
      xx string_reverse!, drop2

      xx literal, sum$digital_string_to_integer
      xx fetch
      xx end

   define_function "help,digital-string->integer", help__digital_string_to_integer
      ;; << reversed-string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end

      xx dup2, string_head__char, char_to_decimal_digital
      xx   literal, 10
      xx   literal, counter$digital_string_to_integer, fetch
      xx     one
      xx     literal, counter$digital_string_to_integer
      xx     add_save
      xx   power
      xx multiple

      xx literal, sum$digital_string_to_integer
      xx add_save

      xx string_tail__char
      xx taca, help__digital_string_to_integer
   #+end_src
** ----------------------------------
** find-char,string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "find-char,string", find_char__string
     ;; << found:
     ;;      string[address, length], char -- address, true >>
     ;; << not found:
     ;;      string[address, length], char -- false >>
     xx over, zero?, false?branch, 5
     xx   drop, drop2
     xx   false
     xx   end
     xx xoverxx, fetch_byte
     xx over, equal?, false?branch, 4
     xx   drop2
     xx   true
     xx   end
     xx xxswapx
     xx string_tail__char
     xx xswapxx
     xx taca, find_char__string
   #+end_src
** test
   #+begin_src cicada-nymph
   : XIE Yuheng ;
   32 find-char,string . << 1 >>
   fetch-byte . << 32 >>
   #+end_src
** ----------------------------------
* io about number
** write-nature-number
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; 2 ^ 64 = 18446744073709551616
   ;; which is of length 20
   ;; so
   ;; I use 32 to align to 16

   buffer$write_nature_number labeling
      preserve 32

   counter$write_nature_number:
      xx 0


   define_function "write-nature-number", write_nature_number
      ;; << nature-number -- >>
      xx zero
      xx literal, counter$write_nature_number, save

      xx help__write_nature_number

      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx string_reverse!
      xx write_string
      xx end


   define_function "help,write-nature-number", help__write_nature_number
      ;; << rest-number -- >>
      xx literal, 10, divmod

      xx decimal_digital_to_char
      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx addition
      xx save_byte

      xx one
      xx literal, counter$write_nature_number
      xx add_save

      xx dup, zero?, false?branch, 3
      xx   drop
      xx   end
      xx taca, help__write_nature_number
   #+end_src
** write-integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-integer", write_integer
      ;; << integer -- >>
      xx dup, positive?, false?branch, 3
      xx   write_nature_number
      xx   end
      xx literal, '-', write_byte
      xx negate
      xx write_nature_number
      xx end
   #+end_src
** pretty_write_integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function ".", pretty_write_integer
      ;; << integer -- >>
      xx write_integer
      xx literal, 32
      xx write_byte
      xx end
   #+end_src
* word
** ----------------------------------
** note io about word
   * words are separated by spaces
   * a bar-ket is a word
     even when there are no spaces around it
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_word_length = 1024

   buffer$read_word labeling
      preserve max_word_length

   buffer$read_word_for_REPL labeling
      preserve max_word_length
   #+end_src
** read-word-begin-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-begin-char", read_word_begin_char
      ;; << -- non-blank-char >>
      xx read_byte
      xx dup, literal, 32 ;; ascii.space
      xx greater_than?, false?branch, 2
      xx   end
      xx drop
      xx taca, read_word_begin_char
   #+end_src
** read-word->buffer
   1. skip any space-char (whitespace newline)
   2. call read_char to read characters into buffer
      until it hits a blank
   3. return the address of buffer and length to argument_stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word->buffer", read_word_to_buffer
      ;; << buffer -- word[address, length] >>
      xx read_word_begin_char
      ;; no metter what the begin char is
      ;; save it into buffer
      xx dup2, swap, save_byte
      xx swap, add1, swap
      xx one, swap ;; leave length counter
      ;; << cursor[address in buffer], counter, begin char >>
      xx dup, bar_ket_char?, false?branch, 4
      xx   drop
      xx   help__read_word_to_buffer__bar_ket
      xx   end
      ;; maybe add other type of chars
      xx drop
      xx help__read_word_to_buffer__regular
      xx end

   define_function "help,read-word->buffer,bar-ket", help__read_word_to_buffer__bar_ket
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx tuck, subtraction
      xx swap
      xx end


   define_function "help,read-word->buffer,regular", help__read_word_to_buffer__regular
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx read_byte
      xx dup, bar_ket_char?, false?branch, 6
      xx   unread_ket_char
      xx   tuck, subtraction
      xx   swap
      xx   end
      xx dup, space_char?, false?branch, 6
      xx   drop
      xx   tuck, subtraction
      xx   swap
      xx   end
      xx xoverxx, save_byte
      xx add1
      xx swap, add1, swap
      xx taca, help__read_word_to_buffer__regular
   #+end_src
** read-word
   * read-word will override the word readed before
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word", read_word
      ;; << -- word[address of buffer$read_word, length] >>
      xx literal, buffer$read_word, read_word_to_buffer
      xx end
   #+end_src
** read-word-for-REPL
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-for-REPL", read_word_for_REPL
      ;; << -- word[address of buffer$read_word_for_REPL, length] >>
      xx literal, buffer$read_word_for_REPL, read_word_to_buffer
      xx end
   #+end_src
** ----------------------------------
** note
   * one should use space-string? to make sure
     that the string is not space-string
     before apply string-[head|tail],word onto the string
** space-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-string?", space_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2, string_head__char, space_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, space_string?
      xx drop2, false
      xx end
   #+end_src
** string->word-[begin|end]
   * the error is not handled
     so
     before calling (string->word-begin)
     one should make sure that
     the argument is not a space-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->word-begin", string_to_word_begin
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, string_to_word_begin

   define_function "string->word-end", string_to_word_end
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 3
      xx   string_tail__char
      xx   end
      xx help__string_to_word_end
      xx end

   define_function "help,string->word-end", help__string_to_word_end
      ;; << string[address, length] -- address >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?branch, 2
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, help__string_to_word_end
   #+end_src
** string-[head|tail],word
   * note that
     the following functions do not create new strings
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,word", string_head__word
      ;; << string[address, length] -- word[address, length] >>
      xx string_to_word_begin
      xx dup2, string_to_word_end
      xx swap, drop
      xx subtraction
      xx end

   define_function "string-tail,word", string_tail__word
      ;; << string[address, length] -- string[address, length] >>
      xx string_to_word_begin
      xx string_to_word_end
      xx end
   #+end_src
** ----------------------------------
* dictionary
** note
   * the dictionary is a single-linked-list
     of word-jo-jojo
   * a jojo is an vector of jo
   * from a jo one can find a jojo
     for example
     this is what the "explain$function" will do
     to help the interpreter
     to explain the mean of a jo
   * from a word one can find a jo
     for example
     this is what the "define-function" will do
     from source code
     it defines new function into dictionary
     by creating new structured data into memory
** find
   * as find
   * find jo in dictionary by word
     but I simply call it "find"
   * a function whoes name is prefixed by "find"
     maybe fail to find
     and maybe returns a signal
     to inform the function who calls it
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*first-jo-in-dictionary*", V__first_jo_in_dictionary
      xx last_jo_in_assembly

   define_function "find", find
      ;; found :
      ;; << word[address, length] -- jo, true >>
      ;; not found :
      ;; << word[address, length] -- false >>
      xx V__first_jo_in_dictionary
      xx help__find
      xx end

   define_function "help,find", help__find
      ;; found :
      ;; << word[address, length], jo -- jo, true >>
      ;; not found :
      ;; << word[address, length], jo -- false >>
      xx xxtuckx
      xx jo_to_name, xxoverxx
      xx string_equal?, false?branch, 4
      xx   drop2, true
      xx   end
      xx xswapxx
      xx dup, last_jo__dictionary?, false?branch, 5
      xx   drop, drop2
      xx   false
      xx   end
      xx jo_to_pre_jo
      xx taca, help__find
   #+end_src
** execute-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "execute-word", execute_word
      ;; << word[address, length] -- unknown >>
      xx dup2, integer_string?, false?branch, 3
      xx   string_to_integer
      xx   end
      ;; maybe more

      xx dup2 ;; for to report undefined word

      xx find, false?branch, 5
      xx   xxswapx, drop2
      xx   execute_jo
      xx   end

      xx write_undefined_word_report__for_execute_word
      xx write_string
      xx literal, 10
      xx write_byte
      xx end


   define_function "write-undefined-word-report,for-execute-word", write_undefined_word_report__for_execute_word
      ;; << -- >>
      xx literal, string$undefined_word_report__for_execute_word
      xx literal, length$undefined_word_report__for_execute_word
      xx write_string
      xx end

   string$undefined_word_report__for_execute_word:
      db "* (execute-word) MEETS UNDEFINED WORD : "
   .end:
   length$undefined_word_report__for_execute_word = (.end - string$undefined_word_report__for_execute_word)
   #+end_src
* basic-REPL
  #+begin_src fasm :tangle cicada-nymph.fasm
  define_function "basic-REPL", basic_REPL
     ;; << unknown -- unknown >>
     xx read_word_for_REPL
     xx execute_word
     xx taca, basic_REPL
  #+end_src
* -----------------------------------
* colon semicolon
** note
   * from the aesthetics point of view
     I do NOT think which of the following is better then the other
     but I choose the second one
   * first:
     #+begin_src
     define-function factorial
       << n -- n! >>
       dup one? if
         end
       then
       dup sub1 factorial *
       end
     end
     #+end_src
   * second:
     #+begin_src cicada-nymph
     : factorial
       << n -- n! >>
       dup one? if
         end
       then
       dup sub1 factorial *
       end
     ; define-function
     #+end_src
** [colon|semicolon]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "colon-string?", colon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ':'
      xx char_string?
      xx end

   define_function "semicolon-string?", semicolon_string?
      ;; << string[address, length] -- bool >>
      xx literal, ';'
      xx char_string?
      xx end
   #+end_src
** comment-[begin|end]-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   string$comment_begin:
      db "<<"

   define_function "comment-begin-string?", comment_begin_string?
      ;; (* string[address, length] -- bool *)
      xx literal, string$comment_begin
      xx literal, 2
      xx string_equal?
      xx end


   string$comment_end:
      db ">>"

   define_function "comment-end-string?", comment_end_string?
      ;; (* -- *)
      xx literal, string$comment_end
      xx literal, 2
      xx string_equal?
      xx end
   #+end_src
** colon & semicolon
   * nested : ; is NOT allow
     and no error check for it
   * nested << >> must be handled
   * comment are handled by : ;
     comment inside : ; are not readed
   * note that
     there might be a ; in << >>
     when this happens
     the ; must NOT be readed
   * note that
     a bar-ket is readed as a word
     double-quote is special bar-ket
     but "<" & ">" are not viewed as bar-ket
   #+begin_src fasm :tangle cicada-nymph.fasm
   buffer$colon labeling
      preserve 1024 * 1024

   cursor$colon:
      xx 0


   define_function ":", colon
      ;; << -- string[address of buffer$colon, length] >>
      xx literal, buffer$colon
      xx literal, cursor$colon, save
      xx help__loop__colon
      ;; address
      xx literal, buffer$colon
      ;; length
      xx literal, cursor$colon, fetch
      xx literal, buffer$colon
      xx subtraction
      xx end


   define_function "", help__loop__colon
      ;; << -- >>
      xx read_byte
      xx help__save_byte__colon
      xx help__meet_end__colon?, false?branch, 7
      xx   literal, 3 ;; for the string " ; "
      xx   literal, cursor$colon
      xx   sub_save
      xx   end
      xx help__meet_comment__colon?, false?branch, 9
      xx   literal, 4 ;; for the string " << "
      xx   literal, cursor$colon
      xx   sub_save
      xx   ignore_comment
      xx   taca, help__loop__colon
      xx taca, help__loop__colon


   define_function "", help__save_byte__colon
      ;; << byte -- >>
      xx literal, cursor$colon, fetch
      xx save_byte
      xx one
      xx literal, cursor$colon
      xx add_save
      xx end


   define_function "", help__meet_end__colon?
      ;; << -- bool >>
      xx literal, cursor$colon, fetch
      xx literal, 3, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 2, subtraction
      xx fetch_byte, literal, ';', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 1, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx true
      xx end

   define_function "", help__meet_comment__colon?
      ;; << -- bool >>
      xx literal, cursor$colon, fetch
      xx literal, 4, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 3, subtraction
      xx fetch_byte, literal, '<', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 2, subtraction
      xx fetch_byte, literal, '<', equal?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx literal, cursor$colon, fetch
      xx literal, 1, subtraction
      xx fetch_byte, space_char?
      xx false?, false?branch, 3
      xx   false
      xx   end
      xx true
      xx end
   #+end_src
** ignore-comment
   * this function is for basic-REPL
     but it is reused by colon
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "<<", ignore_comment
      ;; << -- >>
      xx read_word
      xx dup2, comment_begin_string?, false?branch, 5
      xx   drop2
      xx     ignore_comment ;; for the new nested-comment
      xx   taca, ignore_comment ;; for the rest-comment
      xx dup2, comment_end_string?, false?branch, 3
      xx   drop2
      xx   end
      xx drop2
      xx taca, ignore_comment
   #+end_src
** test
   #+begin_src cicada-nymph
   1 << 989 >> 64 add .
   << 65 >>

   : kkk << 989 << 989 >> >> ; .s
   << kkk >>
   #+end_src
* function & jojo
** ----------------------------------
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   address$jo_heap labeling
      preserve 3 * 1024 * 1024 * jo_size

   define_variable "*current-free-address,jo-heap*", V__current_free_address__jo_heap
      xx address$jo_heap
   #+end_src
** ----------------------------------
** note
   * the make-jojo is a macro dispatcher
     it can be viewed as make-function-body
     it gets next word and use predicates on word to do dispatch
   * note that
     make-jojo can be viewed as the "compiler" of the cicada-nymph
     it does NOT (can not) compile file to file
     but creates structured data directly into memory
** !undo-make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_exception "!undo-make-jojo", !undo_make_jojo
      ;; << old V__current_free_address__primitive_string
      ;;    old V__current_free_address__jo_heap
      ;;    old V__first_jo_in_dictionary
      ;;    string[address, length]
      ;;    -- >>
      xx literal, string$undo_make_jojo_report
      xx literal, length$undo_make_jojo_report
      xx write_string

      xx write_string
      xx literal, 10, write_byte
      xx literal, ';', write_byte
      xx literal, 10, write_byte

      xx address, V__first_jo_in_dictionary, save
      xx address, V__current_free_address__jo_heap, save
      xx address, V__current_free_address__primitive_string
      xx save
      xx end


   string$undo_make_jojo_report:
      db "  THE FOLLOWING JOJO IS NOT MADE :"
      db 10
      db ": "
   .end:
   length$undo_make_jojo_report = (.end - string$undo_make_jojo_report)
   #+end_src
** make-jojo
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "make-jojo", make_jojo
      ;; << string[address, length] -- >>
      xx dup2, space_string?, false?branch, 3
      xx   drop2
      xx   end
      xx dup2
      xx string_tail__word
      xx xxswapxx
      xx string_head__word
      ;; << tail[address, length], head[address, length] >>
      xx make_jojo__dispatch_word
      xx taca, make_jojo

   define_function "make-jojo,dispatch-word", make_jojo__dispatch_word
      ;; << string[address, length], word[address, length] --
      ;;    string[address, length] >>
      xx dup2, integer_string?, false?branch, 7
      xx   literal, literal
      xx     save_into__jo_heap
      xx   string_to_integer
      xx     save_into__jo_heap
      xx     end
      xx dup2
      xx find, false?
      xx false?branch, 7
      xx   write_undefined_word_report__for_make_jojo
      xx   write_string
      xx   literal, 10, write_byte
      xx   !undo_make_jojo
      xx xxswapx, drop2 ;; word
      xx taca, make_jojo__dispatch_jo

   define_function "make-jojo,dispatch-jo", make_jojo__dispatch_jo
      ;; << string[address, length], jo --
      ;;    string[address, length] >>
      xx dup, macro_jo?, false?branch, 3
      xx   execute_jo
      xx   end

      ;; the same to
      ;;   function
      ;;   primitive-function
      ;;   variable
      ;;   exception
      xx save_into__jo_heap
      xx end


   define_function "write-undefined-word-report,for-make-jojo", write_undefined_word_report__for_make_jojo
      ;; << -- >>
      xx literal, string$undefined_word_report__for_make_jojo
      xx literal, length$undefined_word_report__for_make_jojo
      xx write_string
      xx end

   string$undefined_word_report__for_make_jojo:
      db "* (make-jojo) MEETS UNDEFINED WORD : "
   .end:
   length$undefined_word_report__for_make_jojo = (.end - string$undefined_word_report__for_make_jojo)
   #+end_src
** ----------------------------------
** note macro in cicada-nymph
   * a macro is a function to be called at compile time
     with a string to be compiled as one argument
     and do side-effect to store data into memory
     and return a shorter string
     [this can be viewed as moving a cursor forward]
   * a macro should be highlight by text editor in a special way
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_macro "address", M__address
      ;; << string[address, length] -- string[address, length] >>
      xx literal, address
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx find, false?branch, 4
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   end

      xx write_undefined_word_report__for_address
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-undefined-word-report,for-address", write_undefined_word_report__for_address
      ;; << -- >>
      xx literal, string$undefined_word_report__for_address
      xx literal, length$undefined_word_report__for_address
      xx write_string
      xx end

   string$undefined_word_report__for_address:
      db "* (make-jojo (address)) THE WORD FOLLOWS (address) IS UNDEFINED : "
   .end:
   length$undefined_word_report__for_address = (.end - string$undefined_word_report__for_address)
   #+end_src
** branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_macro "branch", M__branch
      ;; << string[address, length] -- string[address, length] >>
      xx literal, branch
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx dup2, integer_string?, false?branch, 5
      xx   string_to_integer
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   end

      xx write_not_integer_string_report__for_branch
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-branch", write_not_integer_string_report__for_branch
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_branch
      xx literal, length$not_integer_string_report__for_branch
      xx write_string
      xx end

   string$not_integer_string_report__for_branch:
      db "* (make-jojo (branch)) THE WORD FOLLOWS (branch) MUST BE A INTEGER STRING : "
   .end:
   length$not_integer_string_report__for_branch = (.end - string$not_integer_string_report__for_branch)
   #+end_src
** false?branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_macro "false?branch", M__false?branch
      ;; << string[address, length] -- string[address, length] >>
      xx literal, false?branch
      xx save_into__jo_heap

      xx dup2
      xx string_head__word
      xx dup2, integer_string?, false?branch, 5
      xx   string_to_integer
      xx   save_into__jo_heap
      xx   string_tail__word
      xx   end

      xx write_not_integer_string_report__for_false?branch
      xx dup2, string_head__word, write_string
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-false?branch", write_not_integer_string_report__for_false?branch
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_false?branch
      xx literal, length$not_integer_string_report__for_false?branch
      xx write_string
      xx end

   string$not_integer_string_report__for_false?branch:
      db "* (make-jojo (false?branch)) THE WORD FOLLOWS (false?branch) MUST BE A INTEGER STRING : "
   .end:
   length$not_integer_string_report__for_false?branch = (.end - string$not_integer_string_report__for_false?branch)
   #+end_src
** double-quote
   * primitive-string-heap is used
     to allocate string literal in function body
   * in ASCII encode double-quote is 34
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_macro '"', M__double_quote
      ;; << string[address, length] -- string[address, length] >>
      xx dup2
      xx literal, '"', find_char__string
      xx false?branch, (.not_found-$)/jo_size
      xx   xoverxx, subtraction
      ;;   << string[address, length], length >>

      ;; address
      xx   literal, literal
      xx     save_into__jo_heap
      xx   V__current_free_address__primitive_string, add2
      xx     save_into__jo_heap
      xx   xoverxx, over
      xx     save_into__primitive_string_heap

      ;; length
      xx   literal, literal
      xx     save_into__jo_heap
      xx   dup
      xx     save_into__jo_heap

      xx   tuck, subtraction
      xx   xxswapx
      xx   addition
      xx   swap

      xx   string_tail__char ;; over the ending double-quote
      xx   end

      .not_found:
      xx write_not_integer_string_report__for_double_quote
      xx literal, 10, write_byte
      xx !undo_make_jojo


   define_function "write-not-integer-string-report,for-double-quote", write_not_integer_string_report__for_double_quote
      ;; << -- >>
      xx literal, string$not_integer_string_report__for_double_quote
      xx literal, length$not_integer_string_report__for_double_quote
      xx write_string
      xx end

   string$not_integer_string_report__for_double_quote:
      db "* (make-jojo (double-quote)) CAN NOT FIND THE ENDING DOUBLE-QUOTE"
   .end:
   length$not_integer_string_report__for_double_quote = (.end - string$not_integer_string_report__for_double_quote)
   #+end_src
** ----------------------------------
** note
   * for the following function
     I add the "CICADA__" as prefix
     to distinguish from their assembly code version
** define-function
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-function", CICADA__define_function
      ;; << string[address, length] -- >>
      xx V__current_free_address__primitive_string, xxswapx
      xx V__current_free_address__jo_heap, xxswapx
      xx V__first_jo_in_dictionary, xxswapx
      xx prepare_for
      xx   exception_head
      xx   !undo_make_jojo
      xx   end_of_prepare


      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx dup2, string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$function
      xx   save_into__jo_heap

      xx dup2, string_tail__word
      xx   make_jojo


      xx drop2
      xx drop, drop, drop
      xx end
   #+end_src
** test
   #+begin_src cicada-nymph
   : addadd add add end ; define-function
   1 2 3 addadd . << 6 >>

   : add1 1 add end ; define-function
   1 add1 . << 2 >>

   : negate 0 swap sub end ; define-function
   1 negate . << -1 >>
   #+end_src
** ----------------------------------
** define-macro
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-macro", CICADA__define_macro
      ;; << string[address, length] -- >>
      xx V__current_free_address__primitive_string, xxswapx
      xx V__current_free_address__jo_heap, xxswapx
      xx V__first_jo_in_dictionary, xxswapx
      xx prepare_for
      xx   exception_head
      xx   !undo_make_jojo
      xx   end_of_prepare


      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx dup2, string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$macro
      xx   save_into__jo_heap

      xx dup2, string_tail__word
      xx   make_jojo


      xx drop2
      xx drop, drop, drop
      xx end
   #+end_src
** ----------------------------------
** define-exception
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-exception", CICADA__define_exception
      ;; << string[address, length] -- >>
      xx V__current_free_address__primitive_string, xxswapx
      xx V__current_free_address__jo_heap, xxswapx
      xx V__first_jo_in_dictionary, xxswapx
      xx prepare_for
      xx   exception_head
      xx   !undo_make_jojo
      xx   end_of_prepare


      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx dup2, string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$exception
      xx   save_into__jo_heap

      xx dup2, string_tail__word
      xx   make_jojo


      xx drop2
      xx drop, drop, drop
      xx end
   #+end_src
** ----------------------------------
** note
   * not undo is needed for define-variable
** define-variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "define-variable", CICADA__define_variable
      ;; << variable, string[address, length] -- >>
      xx V__current_free_address__primitive_string
      xx   save_into__jo_heap
      xx dup2, string_head__word
      xx   save_into__primitive_string_heap

      xx V__first_jo_in_dictionary
      xx jo_to_link
      xx   save_into__jo_heap

      xx V__current_free_address__jo_heap
      xx address, V__first_jo_in_dictionary
      xx save

      xx literal, explain$variable
      xx   save_into__jo_heap

      ;; when debugging
      ;; instead of drop2
      ;; one may wish to do some thing to the string
      xx drop2
      xx save_into__jo_heap
      xx end
   #+end_src
** ----------------------------------
** note
   * you can see how the naming convention is used
     for functions that create structured data into memory
** save-into,primitive-string-heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,primitive-string-heap", save_into__primitive_string_heap
      ;; << string[address, length] -- address >>
      xx dup, V__current_free_address__primitive_string
      xx save_two_bytes

      xx literal, 2
      xx address, V__current_free_address__primitive_string
      xx add_save

      xx tuck
      xx V__current_free_address__primitive_string
      xx string_to_buffer!

      xx address, V__current_free_address__primitive_string
      xx add_save
      xx end
   #+end_src
** save-into,jo-heap
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "save-into,jo-heap", save_into__jo_heap
      ;; << number -- address >>
      xx V__current_free_address__jo_heap
      xx save

      xx literal, jo_size
      xx address, V__current_free_address__jo_heap
      xx add_save
      xx end
   #+end_src
** ----------------------------------
** test
   #+begin_src cicada-nymph
   233 : *three* ; define-variable
   : add-three *three* add end ; define-function
   1 add-three . << 234 >>

   << you get the address of the variable *three*
      by add "address" in front of it >>
   : fix-*three* 3 address *three* save end ; define-function
   fix-*three*
   1 add-three . << 4 >>
   #+end_src
** ----------------------------------
* -----------------------------------
* epilog
** ----------------------------------
** *current-free-address,primitive-string-heap*
   * the last_primitive_string_in_assembly
     is just "*current-free-address,primitive-string-heap*"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*current-free-address,primitive-string-heap*", V__current_free_address__primitive_string
      xx current_free_address$primitive_string_heap
   #+end_src
** ----------------------------------
** last_jo_in_assembly
   * this word helps to initialize V__first_jo_in_dictionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "", last_jo_in_assembly
      ;; << -- >>
      xx 0
   #+end_src
** ----------------------------------
** un_initialized_memory [linux]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if linux? eq yes

   size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

   segment readable writeable
   address$un_initialized_memory:
      rb size$un_initialized_memory

   finish if
   #+end_src
** ----------------------------------
** un_initialized_memory [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes

   size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

   section '.data' data readable writeable
   address$un_initialized_memory:
      rb size$un_initialized_memory

   finish if
   #+end_src
** import [windows]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if windows? eq yes


   ;; Macroinstructions for making import section (64-bit)

   macro library [name,string]
    { common
       import.data:
      forward
       local _label
       if defined name#.redundant
        if ~ name#.redundant
         dd RVA name#.lookup,0,0,RVA _label,RVA name#.address
        finish if
       finish if
       name#.referred = 1
      common
       dd 0,0,0,0,0
      forward
       if defined name#.redundant
        if ~ name#.redundant
         _label db string,0
                rb RVA $ and 1
        finish if
       finish if }

   macro import name,[label,string]
    { common
       rb (- rva $) and 7
       if defined name#.referred
        name#.lookup:
      forward
        if used label
         if string eqtype ''
          local _label
          dq RVA _label
         else
          dq 8000000000000000h + string
         finish if
        finish if
      common
        if $ > name#.lookup
         name#.redundant = 0
         dq 0
        else
         name#.redundant = 1
        finish if
        name#.address:
      forward
        if used label
         if string eqtype ''
          label dq RVA _label
         else
          label dq 8000000000000000h + string
         finish if
        finish if
      common
        if ~ name#.redundant
         dq 0
        finish if
      forward
        if used label & string eqtype ''
        _label dw 0
               db string,0
               rb RVA $ and 1
        finish if
      common
       finish if }


   section '.idata' import data readable writeable

   library kernel32,'KERNEL32.DLL'

   import kernel32,\
          ExitProcess,'ExitProcess',\
          ReadFile,'ReadFile',\
          WriteFile,'WriteFile',\
          GetStdHandle,'GetStdHandle'


   finish if
   #+end_src
** ----------------------------------
* ===================================
* if & else & then
  * one predicate can make two branchs
    three predicates can make four branchs
    three predicates may only make three branchs
    but indeed there must be an invisible branch
  #+begin_src cicada-nymph :tangle core.cn
  : if
    << string[address, length] --
       address, string[address, length] >>
    *false?branch* save-into,jo-heap
    *current-free-address,jo-heap* xx|swap|x
    0 save-into,jo-heap
    end
  ; define-macro

  : else
    << address, string[address, length] --
       address, string[address, length] >>
    *branch* save-into,jo-heap
    x|swap|xx
    *current-free-address,jo-heap* xxx|swap|x
    0 save-into,jo-heap
    << address, string[address, length], address >>
    *current-free-address,jo-heap*
    over sub *jo-size* div
    swap save
    end
  ; define-macro

  : then
    << address, string[address, length] --
       string[address, length] >>
    x|swap|xx
    *current-free-address,jo-heap*
    over sub *jo-size* div
    swap save
    end
  ; define-macro
  #+end_src
* test
  #+begin_src cicada-nymph
  : factorial
    << number -- number >>
    dup one? if
      end
    then
    dup sub1 factorial
    mul
    end
  ; define-function


  1 factorial .
  2 factorial .
  3 factorial .
  4 factorial .
  5 factorial .
  6 factorial .
  7 factorial .
  8 factorial .
  9 factorial .
  10 factorial .
  11 factorial .
  12 factorial .
  13 factorial .
  14 factorial .
  15 factorial .
  16 factorial .
  17 factorial .
  18 factorial .
  19 factorial .
  20 factorial .


  : cr
    10 write-byte
    end
  ; define-function


  : .12
    << 1 2 -- >>
    2 equal? if
      "(^-^)" write-string
      1 equal? if
        "\^o^/" write-string
      else
        "     " write-string
      then
    else
      "     " write-string
      1 equal? if
        "\^o^/" write-string
      else
        "     " write-string
      then
    then
    end
  ; define-function

  cr
  1 2 .12 cr
  6 2 .12 cr
  1 6 .12 cr
  6 6 .12 cr
  #+end_src
* -----------------------------------
* re-define execute-word & basic-REPL
  * to protect macro & exception from be called from basic-REPL
  #+begin_src cicada-nymph :tangle core.cn
  : execute-word
    << word[address, length] -- unknown >>
    dup2 integer-string? if
      string->integer
      end
    then
    dup2
    find if
      dup macro-jo? if
        drop
        "* (execute-word) CAN NOT EXECUTE MACRO DIRECTLY : " write-string
        write-string 10 write-byte
        end
      then
      dup exception-jo? if
        drop
        "* (execute-word) CAN NOT EXECUTE EXCEPTION DIRECTLY : " write-string
        write-string 10 write-byte
        end
      then
      << function & primitive-function & variable >>
      xx|swap|x drop2
      execute-jo
      end
    else
    "* (execute-word) MEETS UNDEFINED WORD : " write-string
    write-string 10 write-byte
    then
    end
  ; define-function

  : basic-REPL
    << unknown -- unknown >>
    read-word-for-REPL
    execute-word
    <> basic-REPL
  ; define-function

  basic-REPL
  #+end_src
* ===================================
