#+TITLE:  齡四 / 4th-instar
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* ===================================
* note instar
** 1st-instar
   * indirect-threaded-code interpreter
     1. macro about argument_stack & return_stack
     2. macro about jo & jojo
     3. macro about next
     4. the way to do memory allocation
     5. begin_to_interpret_threaded_code
     6. little_test
** 2ed-instar
   * instruction as special primitive function
     1. literal
     2. address
   * and primitive functions about
     1. the stack
     2. bool
     3. fixnum
     4. memory
   * and taca for explicit tail-call
   * false?branch and taca are needed for "power"
** 3rd-instar
   * primitive function about io
     1. write_byte
     2. read_byte
** 4th-instar
   * more function about io
     1. about word
     2. about string
     3. about number
   * more function
     1. jo
     2. char
     3. buffer
   * more in epilog
     1. last_link
   * function about dictionary
     1. find
     2. execute-word
   * basic-REPL as postfix-notation function executer
     1. basic-REPL
* ===================================
* prolog
** ----------------------------------
** platform configuration
   #+begin_src fasm :tangle cicada-nymph.fasm
   define platform windows
   define machine  32bit
   #+end_src
** misc
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate

   ;; in fasm, "end" is a reserved word
   finish equ end
   end equ exit
   #+end_src
** ----------------------------------
** jo_size [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   jo_size = 4 ;; (byte)
   xx equ dd

   rax equ eax
   rbx equ ebx
   rcx equ ecx
   rdx equ edx
   rsp equ esp
   rbp equ ebp
   rsi equ esi
   rdi equ edi

   syscall equ int 80h

   }
   #+end_src
** ----------------------------------
** note calling convention
   * [[https://msdn.microsoft.com/en-us/library/k2b2ssfy.aspx][Calling Conventions]]
   * [[https://msdn.microsoft.com/en-us/library/a5s9345t.aspx][Calling Example: Function Prototype and Call]]
     [[https://msdn.microsoft.com/en-us/library/25687bhx.aspx][Results of Calling Example]]
** header [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   define STD_INPUT_HANDLE  -10
   define STD_OUTPUT_HANDLE -11

   }
   #+end_src
** format [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   format PE console as "32.exe"

   }
   #+end_src
** entry  [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   entry begin_to_interpret_threaded_code
   section '.text' code writeable readable executable

   }
   #+end_src
** ----------------------------------
** memory allocation in un_initialized_memory
   * implemented as a memory map
   #+begin_src fasm :tangle cicada-nymph.fasm
   current_free_address$un_initialized_memory = address$un_initialized_memory

   labeling  equ = current_free_address$un_initialized_memory
   preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
   #+end_src
** ----------------------------------
* -----------------------------------
* note stack
  * when doing "push"
    a stack-pointer moves to lower address
  * note that another style is that
    when doing "push"
    a stack-pointer moves to higher address
  * the stack-pointer
    always stores the address of current-free-address of the stack
  * note that another style is that
    under the stack-pointer
    there always stores the value of the-top-of-the-stack
* argument_stack
** ----------------------------------
** memory allocation
   * for we do not build border-check
     into the interface of pop and push
     we allocation some memory below the stacks
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve 64 * jo_size
   address$argument_stack labeling
      preserve 1024 * 1024 * jo_size
   #+end_src
** ----------------------------------
** pointer    [64bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   define pointer$argument_stack r15

   }
   #+end_src
** push & pop [64bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   macro push_argument_stack register \{
      mov [pointer$argument_stack], register
      add pointer$argument_stack, jo_size
   \}

   macro pop_argument_stack register \{
      sub pointer$argument_stack, jo_size
      mov register, [pointer$argument_stack]
   \}

   }
   #+end_src
** ----------------------------------
** pointer    [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   pointer$argument_stack:
      xx address$argument_stack

   }
   #+end_src
** push & pop [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   macro push_argument_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$argument_stack]
      mov [ebx], register
      add ebx, jo_size
      mov [pointer$argument_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$argument_stack]
      mov [eax], register
      add eax, jo_size
      mov [pointer$argument_stack], eax
      pop eax
      finish if
   \}

   macro pop_argument_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$argument_stack]
      sub ebx, jo_size
      mov register, [ebx]
      mov [pointer$argument_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$argument_stack]
      sub eax, jo_size
      mov register, [eax]
      mov [pointer$argument_stack], eax
      pop eax
      finish if
   \}

   }
   #+end_src
** ----------------------------------
* return_stack
** ----------------------------------
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
      preserve 64 * jo_size
   address$return_stack labeling
      preserve 1024 * 1024 * jo_size
   #+end_src
** ----------------------------------
** pointer    [64bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   ;; if you want to extend cicada in assembly
   ;; the following registers must NOT be used

   define pointer$return_stack r14

   }
   #+end_src
** push & pop [64bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   macro push_return_stack register \{
      mov [pointer$return_stack], register
      add pointer$return_stack, jo_size
   \}

   macro pop_return_stack register \{
      sub pointer$return_stack, jo_size
      mov register, [pointer$return_stack]
   \}

   }
   #+end_src
** ----------------------------------
** pointer    [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   pointer$return_stack:
      xx address$return_stack

   }
   #+end_src
** push & pop [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   macro push_return_stack register \{
      if register in <eax>
      push ebx
      mov ebx, [pointer$return_stack]
      mov [ebx], register
      add ebx, jo_size
      mov [pointer$return_stack], ebx
      pop ebx
      else
      push eax
      mov eax, [pointer$return_stack]
      mov [eax], register
      add eax, jo_size
      mov [pointer$return_stack], eax
      pop eax
      finish if
   \}

   macro pop_return_stack register \{
      if register in <eax>
      mov ebx, [pointer$return_stack]
      sub ebx, jo_size
      mov register, [ebx]
      mov [pointer$return_stack], ebx
      else
      mov eax, [pointer$return_stack]
      sub eax, jo_size
      mov register, [eax]
      mov [pointer$return_stack], eax
      finish if
   \}

   }
   #+end_src
** ----------------------------------
* -----------------------------------
* next
  #+begin_src fasm :tangle cicada-nymph.fasm
  match =64bit, machine {

  macro next \{
     pop_return_stack rbx
       mov rax, [rbx]
     add rbx, jo_size
     push_return_stack rbx
       jmp qword [rax]
  \}

  }


  match =32bit, machine {

  macro next \{
     pop_return_stack rbx
       mov rax, [rbx]
     add rbx, jo_size
     push_return_stack rbx
       jmp dword [rax]
  \}

  }
  #+end_src
* note play with jo & jojo
  1. at the beginning
     * argument-stack
       << 2 >>
     * return-stack
       #+begin_src return-stack
       - [ (square) ]
           (square)
           (end)
       #+end_src
  2. next
     * argument-stack
       << 2 >>
     * return-stack
       #+begin_src return-stack
           (square)
       - [ (square) ] - [ (dup) ]
           (end)          (multiple)
                          (end)
       #+end_src
  3. next
     * argument-stack
       << 2, 2 >>
     * return-stack
       #+begin_src return-stack
           (square)       (dup)
       - [ (square) ] - [ (multiple) ]
           (end)          (end)
       #+end_src
  4. next
     * argument-stack << 4 >>
     * return-stack
       #+begin_src return-stack
                          (dup)
           (square)       (multiple)
       - [ (square) ] - [ (end) ]
           (end)
       #+end_src
  5. next
     * argument-stack << 4 >>
     * return-stack
       #+begin_src return-stack
           (square)
           (square)
       - [ (end) ] - [ (dup) ]
                       (multiple)
                       (end)
       #+end_src
  6. next
     * argument-stack
       << 4, 4 >>
     * return-stack
       #+begin_src return-stack
           (square)
           (square)    (dup)
       - [ (end) ] - [ (multiple) ]
                       (end)
       #+end_src
  7. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
           (square)    (dup)
           (square)    (multiple)
       - [ (end) ] - [ (end) ]
       #+end_src
  8. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
           (square)
           (square)
       - [ (end) ]
       #+end_src
  9. next
     * argument-stack
       << 16 >>
     * return-stack
       #+begin_src return-stack
       - [  ]
       #+end_src
  10. it is really simple
      ^-^
      is it not ?
* -----------------------------------
* helper function in assembly code
** ----------------------------------
** __exit_with_TOS  [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   __exit_with_TOS:

      pop_argument_stack rax
      push rax
      call [ExitProcess]

   }
   #+end_src
** __exit_with_zero [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   __exit_with_zero:

      push 0
      call [ExitProcess]

   }
   #+end_src
** __exit_with_six  [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   __exit_with_six:

      push 6
      call [ExitProcess]

   }
   #+end_src
** ----------------------------------
* -----------------------------------
* macro for jo & explainer
** ----------------------------------
** link
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; initial link to point to 0 (as null)
   link = 0
   #+end_src
** ----------------------------------
** note primitive_string_heap
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   size$primitive_string_heap = 100 * 1024 ;; (byte)

   address$primitive_string_heap:
      times size$primitive_string_heap db 0

   current_free_address$primitive_string_heap = address$primitive_string_heap
   #+end_src
** make_primitive_string
   * 2 bytes for length of name_string
   * note that
     the following is using local label
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro make_primitive_string string {

   virtual at 0
   .start$string:
      db string
   .end$string:
      dw (.end$string - .start$string)
      load .length word from (.end$string)
   finish virtual
   store word .length at (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

   repeat .length
      virtual at 0
         db string
         load .char byte from (% - 1)
      finish virtual
      store byte .char at (current_free_address$primitive_string_heap)
      current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
   finish repeat

   }
   #+end_src
** ----------------------------------
** note
   * note that
     after a "next" "jmp" to a explainer
     the "rax" stores the value of the jo to be explained
     so
     "rax" is used as an inexplicit argument
     of the following functions
   * explain$function is used as jojo-head
     and explains the meaning of the jojo as function
   * a jojo-head identifies one type of jo
** define_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_function string, jo {

   define_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$function

      ;; here follows a jojo as function-body

   }
   #+end_src
** explain$function
   * find a jojo from a function-jo
     and push the jojo to return-stack
   * a jojo can not be of size 0
   * use rax as an argument
     which stores a jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$function:
      add rax, jo_size
      push_return_stack rax
      next
   #+end_src
** ----------------------------------
** note
   * primitive functions are special
     they explain themself
     and their type is not identified by jojo-head
** define_primitive_function
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_primitive_function string, jo {

   define_primitive_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx assembly_code__#jo

   assembly_code__#jo:

      ;; here follows assembly code
      ;; as primitive function body

   }
   #+end_src
** ----------------------------------
** note
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
** define_variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   macro define_variable string, jo {

   define_variable__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_primitive_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$variable

      ;; here follows a value of jo_size
      ;; only one value is allowed

   }
   #+end_src
** explain$variable
   #+begin_src fasm :tangle cicada-nymph.fasm
   explain$variable:
      add rax, jo_size
      mov rbx, [rax]
      push_argument_stack rbx
      next
   #+end_src
** ----------------------------------
* execute-jo & structure of jo
** ----------------------------------
** execute-jo
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- UNKNOWN >>
      pop_argument_stack rax
      jmp qword [rax]

   }


   match =32bit, machine {

   define_primitive_function "execute-jo", execute_jo
      ;; << jo -- UNKNOWN >>
      pop_argument_stack eax
      jmp dword [eax]

   }
   #+end_src
** ----------------------------------
** *jo-size*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*jo-size*", V__jo_size
      xx jo_size
   #+end_src
** jo->name
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->name", jo_to_name
      ;; << jo -- string[address, length] >>
      xx literal, jo_size, subtraction
      xx literal, jo_size, subtraction
      xx fetch
      xx address_to_primitive_string
      xx end
   #+end_src
** jo->link
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->link", jo_to_link
      ;; << jo -- link >>
      xx literal, jo_size
      xx subtraction
      xx end
   #+end_src
** last-jo,dictionary?
   * first jo in assembly code
     is the last jo in dictionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "last-jo,dictionary?", last_jo__dictionary?
      ;; << jo -- bool >>
      xx jo_to_link
      xx fetch
      xx zero?
      xx end
   #+end_src
** jo->pre-jo
   * treat last-jo,dictionary specially
     i.e. return zero on that case
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->pre-jo", jo_to_pre_jo
      ;; << jo -- pre-jo >>
      xx jo_to_link
      xx fetch
      xx dup, zero?, false?branch, 2
      xx   end
      xx literal, jo_size
      xx addition
      xx end
   #+end_src
** jo->type
   * the type of primitive function jo
     is encoded by 0
   * other types of jo
     are encoded by their explainers
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "jo->type", jo_to_type
      ;; << jo -- type >>
      xx dup

      xx dup, fetch
      xx swap, subtraction, literal, jo_size, equal?, false?branch, 4
      xx   drop, zero
      xx   end

      xx fetch
      xx end
   #+end_src
** ----------------------------------
* primitive-string-heap
** *primitive-string-heap*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*primitive-string-heap*", V__primitive_string_heap
      xx address$primitive_string_heap

   define_variable "*size,primitive-string-heap*", V__size__primitive_string_heap
      xx size$primitive_string_heap

   ;; *current-free-address,primitive-string-heap*
   ;; is at epilog
   #+end_src
** address->primitive-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "address->primitive-string", address_to_primitive_string
      ;; << address -- string[address, length] >>
      xx dup
      xx literal, 2, addition  ;; address
      xx swap, fetch_two_bytes ;; length
      xx end
   #+end_src
* -----------------------------------
* end & taca
** end
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "end", end
      pop_return_stack rbx
      next
   #+end_src
** taca
   * tail-call
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   define_primitive_function "<>", taca
      pop_return_stack rbx
      mov rax, [rbx]
      jmp qword [rax]
   }


   match =32bit, machine {

   define_primitive_function "<>", taca
      pop_return_stack rbx
      mov rax, [rbx]
      jmp dword [rax]

   }
   #+end_src
** note explicit tail call in action
   1. the tail position of a function body must be recognized
      explicit tail call is used to achieve this
   2. thus
      tail-recursive-call can be use to do loop
      without pushing too many address into return-stack
   3. for example if we have a function
      which is called "example"
      #+begin_src fasm
      define_function "example", example
         xx fun1
         xx fun2
         xx taca, example
      #+end_src
   4. and we have the following jojo in return-stack
      #+begin_src return-stack
      - [ (example) ]
          (end)
      #+end_src
   5. next
      #+begin_src return-stack
          (example)
      - [ (end) ] - [ (fun1) ]
                      (fun2)
                      (taca)
                      (example)
      #+end_src
   6. next
      #+begin_src return-stack
          (example)   (fun1)
      - [ (end) ] - [ (fun2) ]
                      (taca)
                      (example)
      #+end_src
   7. next
      #+begin_src return-stack
                      (fun1)
          (example)   (fun2)
      - [ (end) ] - [ (taca) ]
                      (example)
      #+end_src
   8. next
      by the definition of taca
      #+begin_src return-stack
          (example)
      - [ (end) ] - [ (fun1) ]
                      (fun2)
                      (taca)
                      (example)
      #+end_src
   9. you can see return-stack of (8.)
      is the same as (5.)
      it is clear how the example function
      is actually a loop now
* -----------------------------------
* *the story begin*
** begin_to_interpret_threaded_code [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   _output_handle:
      xx 0
   _input_handle:
      xx 0

   begin_to_interpret_threaded_code:

      cld ;; set DF = 0, then rsi and rdi are incremented

      push STD_INPUT_HANDLE
      call [GetStdHandle]
      mov [_input_handle], rax

      push STD_OUTPUT_HANDLE
      call [GetStdHandle]
      mov [_output_handle], rax

      mov rax, first_jojo
      push_return_stack rax
      next

   }
   #+end_src
** first_jojo
   * you can use the following "xx little_test"
     to do some little tests
   #+begin_src fasm :tangle cicada-nymph.fasm
   first_jojo:
      xx little_test
   #+end_src
** exit_with_TOS a.k.a. bye
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "bye", exit_with_TOS
      call __exit_with_TOS
   #+end_src
** little_test
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "", V__little_test_number
      xx 3


   define_function "little_test", little_test

      ;;;; variable
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; exit ocde : 3

      ;;;; literal
      ;; xx literal, 4
      ;; xx exit_with_TOS
      ;;;; exit ocde : 4

      ;;;; address
      ;; xx address, V__little_test_number, fetch, add2
      ;; xx address, V__little_test_number, save
      ;; xx V__little_test_number
      ;; xx exit_with_TOS
      ;;;; exit ocde : 5

      ;;;; taca
      ;; xx literal, 2
      ;; xx literal, 4
      ;; xx power
      ;; xx exit_with_TOS
      ;;;; exit ocde : 16

      ;;;; write_byte
      ;; xx literal, 64, write_byte
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; @

      ;;;; read_byte
      ;; xx read_byte, write_byte
      ;; xx exit_with_TOS
      ;;;;

      ;;;; branch
      ;; xx read_byte, write_byte
      ;; xx branch, -3
      ;;;; read a string that ended by <return>
      ;;;; write the readed string
      ;;;; or we can say
      ;;;; read line and write line
      ;;;; or we can say
      ;;;; echo line

      ;;;; false?branch
      ;; xx false, false?branch, 9
      ;; xx   literal, 64, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx true, false?branch, 9
      ;; xx   literal, 65, write_byte
      ;; xx   literal, 10, write_byte
      ;; xx   zero
      ;; xx   exit_with_TOS
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; A

      ;;;; read_word & write_string
      xx read_word, write_string
      xx literal, 10, write_byte
      xx read_word_for_REPL, write_string
      xx literal, 10, write_byte
      xx zero
      xx exit_with_TOS
      ;;;; read line
      ;;;; write first two words of the line

      ;;;; string->integer
      ;; xx read_word, string_to_integer
      ;; xx exit_with_TOS
      ;;;; type 123
      ;;;; exit code 123

      ;;;; use jo_to_name to test the macro make_primitive_string
      ;; xx literal, jo_to_name, jo_to_name, write_string
      ;; xx literal, 10, write_byte
      ;; xx literal, addition, jo_to_name, write_string
      ;; xx literal, 10, write_byte
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; print "jo->name"
      ;;;; print "add"

      ;;;; xxoverxx
      ;; xx literal, 1
      ;; xx literal, 2
      ;; xx literal, 3
      ;; xx literal, 4
      ;; xx xxoverxx
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx pretty_write_integer
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; 2 1 4 3 2 1

      ;;;; find
      ;; xx read_word, string_to_integer ;; number
      ;; xx read_word, string_to_integer ;; number
      ;; xx read_word, find ;; add
      ;; xx drop ;; true
      ;; xx execute_jo
      ;; xx write_integer
      ;; xx zero
      ;; xx exit_with_TOS
      ;;;; 1 2 add
      ;;;; print "3"

      ;;;; basic-REPL (without the ability to define function)
      ;;;; after this test
      ;;;; we will use basic-REPL to do further tests
      ;; xx basic_REPL
      ;;;; 1 2 add .
   #+end_src
* -----------------------------------
* the stack
** ----------------------------------
** drop
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "drop", drop
      ;; << a -- >>
      pop_argument_stack rax
      next

   define_primitive_function "drop2", drop2
      ;; << a b -- >>
      pop_argument_stack rax
      pop_argument_stack rax
      next
   #+end_src
** dup  [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "dup", dup
      ;; << a -- a a >>
      pop_argument_stack rax
      push_argument_stack rax
      push_argument_stack rax
      next

   define_primitive_function "dup2", dup2
      ;; << a b -- a b a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   }
   #+end_src
** over [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "over", over
      ;; << a b -- a b | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xx", xoverxx
      ;; << a | b c -- a | b c | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|x", xxoverx
      ;; << a b | c -- a b | c | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (2 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xx", xxoverxx
      ;; << a b | c d -- a b | c d | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (4 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (3 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "x|over|xxx", xoverxxx
      ;; << a | b c d -- a | b c d | a >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (4 * jo_size)]
      push_argument_stack rax
      next

   define_primitive_function "xx|over|xxxx", xxoverxxxx
      ;; << a b | c d e f -- a b | c d e f | a b >>
      mov rbx, [pointer$argument_stack]
      mov rax, [rbx - (6 * jo_size)]
      push_argument_stack rax
      mov rax, [rbx - (5 * jo_size)]
      push_argument_stack rax
      next

   }
   #+end_src
** tuck
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "tuck", tuck
      ;; << a b -- b | a b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rax
      push_argument_stack rbx
      next

   define_primitive_function "x|tuck|xx", xtuckxx
      ;; << a | b c -- b c | a | b c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|x", xxtuckx
      ;; << a b | c -- c | a b | c >>
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      next

   define_primitive_function "xx|tuck|xx", xxtuckxx
      ;; << a b | c d -- c d | a b | c d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rcx
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next

   define_primitive_function "xxx|tuck|x", xxxtuckx
      ;; << a b c | d -- d | a b c | d >>
      pop_argument_stack rdx
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      push_argument_stack rdx
      push_argument_stack rax
      push_argument_stack rbx
      push_argument_stack rcx
      push_argument_stack rdx
      next
   #+end_src
** swap [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "swap", swap
      ;; << a b -- b a >>
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack eax
      next

   define_primitive_function "x|swap|xx", xswapxx
      ;; << a | b c -- b c | a >>
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack eax
      next

   define_primitive_function "xx|swap|x", xxswapx
      ;; << a b | c -- c | a b >>
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack eax
      push_argument_stack ebx
      next

   define_primitive_function "x|swap|xxx", xswapxxx
      ;; << a | b c d -- b c d | a >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      push_argument_stack eax
      next

   define_primitive_function "xxx|swap|x", xxxswapx
      ;; << a b c | d -- d | a b c >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack edx
      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      next

   define_primitive_function "xx|swap|xx", xxswapxx
      ;; << a b | c d -- c d | a b >>
      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack edx
      push_argument_stack eax
      push_argument_stack ebx
      next


   define_primitive_function "x|swap|xxxx", xswapxxxx
      ;; << a | b c d e -- b c d e | a >>
      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx

      pop eax
      push_argument_stack eax ;; e

      push_argument_stack eax
      next

   define_primitive_function "xxxx|swap|x", xxxxswapx
      ;; << a b c d | e --  e | a b c d >>
      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax

      pop eax
      push_argument_stack eax ;; e

      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      next


   define_primitive_function "xx|swap|xxxx", xxswapxxxx
      ;; << a b | c d e f -- c d e f | a b >>
      pop_argument_stack eax ;; f
      push eax

      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax
      push_argument_stack ecx
      push_argument_stack edx

      pop eax
      push_argument_stack eax ;; e

      pop eax
      push_argument_stack eax ;; f

      push_argument_stack eax
      push_argument_stack ebx
      next

   define_primitive_function "xxxx|swap|xx", xxxxswapxx
      ;; << a b c d | e f --  e f | a b c d >>
      pop_argument_stack eax ;; f
      push eax

      pop_argument_stack eax ;; e
      push eax

      pop_argument_stack edx
      pop_argument_stack ecx
      pop_argument_stack ebx
      pop_argument_stack eax

      pop eax
      push_argument_stack eax ;; e

      pop eax
      push_argument_stack eax ;; f

      push_argument_stack eax
      push_argument_stack ebx
      push_argument_stack ecx
      push_argument_stack edx
      next

   }
   #+end_src
** ----------------------------------
* instruction
** ----------------------------------
** note side-effect
   * an instruction
     is a special primitive function
     which does special side-effect on return-stack
   * note that
     side-effect on return-stack
     should all be done in primitive functions
** note naming
   * the naming convention in assembly code
     of instruction
     is the same as it of jo
   * the name of an instruction
     might not be exported to cicada-language as a function
     but as a variable
   * the name of a special primitive function in assembly code
     maybe reused as a macro word in cicada-language
     but the name of the macro in assembly code
     is prefixed by "M__"
** ----------------------------------
** literal
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*literal*", V__literal
      xx literal

   define_primitive_function "", literal
      ;; << -- fixnum >>
      pop_return_stack rbx
        mov rax, [rbx]
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** address
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*address*", V__address
      xx address

   define_primitive_function "", address
      ;; << -- address >>
      pop_return_stack rbx
        mov rax, [rbx]
        add rax, jo_size
        push_argument_stack rax
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
** branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*branch*", V__branch
      xx branch

   define_primitive_function "", branch
      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next
   #+end_src
** false?branch
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*false?branch*", V__false?branch
      xx false?branch

   define_primitive_function "", false?branch
      ;; << true of false -- >>
      pop_argument_stack rax
      test rax, rax
      jnz help__false?branch__not_to_branch

      pop_return_stack rbx
      mov rax, [rbx]
      imul rax, jo_size
      add rbx, rax
      push_return_stack rbx
      next

   help__false?branch__not_to_branch:
      pop_return_stack rbx
      add rbx, jo_size
      push_return_stack rbx
      next
   #+end_src
** ----------------------------------
* bool
** false & true
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "false", false
      ;; << -- false >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "true", true
      ;; << -- true >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** false? & true?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "false?", false?
      ;; << bool -- bool >>
      xx false, equal?
      xx end

   define_function "true?", true?
      ;; << bool -- bool >>
      xx true, equal?
      xx end
   #+end_src
** bitwise operations [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "bitwise-and", bitwise_and
      ;; << a, b -- a and b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      and [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-or", bitwise_or
      ;; << a, b -- a or b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      or  [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-xor", bitwise_xor
      ;; << a, b -- a xor b >>
      pop_argument_stack rbx
      mov rax, [pointer$argument_stack]
      xor [rax - (1 * jo_size)], rbx
      next

   define_primitive_function "bitwise-invert", bitwise_invert
      ;; << a -- invert a >>
      mov rax, [pointer$argument_stack]
      not dword [rax - (1 * jo_size)]
      next

   }
   #+end_src
* fixnum
** ----------------------------------
** zero & one
   * they are defined as function
     and viewed as constant
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "zero", zero
      ;; << -- 0 >>
      xor rax, rax
      push_argument_stack rax
      next

   define_primitive_function "one", one
      ;; << -- 1 >>
      xor rax, rax
      inc rax
      push_argument_stack rax
      next
   #+end_src
** zero? & one?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero?", zero?
      ;; << bool -- bool >>
      xx zero, equal?
      xx end

   define_function "one?", one?
      ;; << bool -- bool >>
      xx one, equal?
      xx end
   #+end_src
** ----------------------------------
** add & sub [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "add1", add1
      ;; << n -- n+1 >>
      pop_argument_stack rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add2", add2
      ;; << n -- n+2 >>
      pop_argument_stack rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add3", add3
      ;; << n -- n+3 >>
      pop_argument_stack rax
      inc rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add4", add4
      ;; << n -- n+4 >>
      pop_argument_stack rax
      inc rax
      inc rax
      inc rax
      inc rax
      push_argument_stack rax
      next

   define_primitive_function "add8", add8
      ;; << n -- n+8 >>
      pop_argument_stack rax
      add rax, 8
      push_argument_stack rax
      next


   define_primitive_function "sub1", sub1
      ;; << n -- n-1 >>
      pop_argument_stack rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub2", sub2
      ;; << n -- n-2 >>
      pop_argument_stack rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub3", sub3
      ;; << n -- n-3 >>
      pop_argument_stack rax
      dec rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub4", sub4
      ;; << n -- n-4 >>
      pop_argument_stack rax
      dec rax
      dec rax
      dec rax
      dec rax
      push_argument_stack rax
      next

   define_primitive_function "sub8", sub8
      ;; << n -- n-8 >>
      pop_argument_stack rax
      sub rax, 8
      push_argument_stack rax
      next


   define_primitive_function "add", addition
      ;; << a b -- a+b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      add rax, rbx
      push_argument_stack rax
      next

   define_primitive_function "sub", subtraction
      ;; << a b -- a-b >>
      pop_argument_stack rbx
      pop_argument_stack rax
      sub rax, rbx
      push_argument_stack rax
      next

   }
   #+end_src
** mul
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "mul", multiple
      ;; << a b -- a*b >>
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      imul rbx, rax
      ;; imul will ignore overflow
      ;; when there are two registers as arg
      ;; imul will save the result into the first register
      push_argument_stack rbx
      next
   #+end_src
** negate
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negate", negate
      ;; << n --  -n >>
      xx zero
      xx swap, subtraction
      xx end
   #+end_src
** power
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "power", power
      ;; n must be nature number for now
      ;; << a, n -- a^n >>
      xx literal, 1, swap ;; leave product
      xx help__power
      xx end

   define_function "help,power", help__power
      ;; << a, product, n -- a^n >>
      xx dup, zero?, false?branch, 5
      xx   drop, swap, drop
      xx   end
      xx sub1
      xx swap
      xx   xoverxx, multiple
      xx swap
      xx taca, help__power
   #+end_src
** div & mod
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "moddiv", moddiv
      ;; << a, b -- a mod b, quotient >>
      ;; << dividend, divisor -- remainder, quotient >>
      ;; the arg of idiv is divisor
      ;; the lower half of dividend is taken from rax
      ;; the upper half of dividend is taken from rdx
      xor  rdx, rdx   ;; high-part of dividend is not used
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      idiv rbx
      ;; the remainder is stored in rdx
      ;; the quotient  is stored in rax
      push_argument_stack rdx ;; remainder
      push_argument_stack rax ;; quotient
      next


   define_function "divmod", divmod
      ;; << a, b -- quotient, a mod b >>
      xx moddiv, swap
      xx end

   define_function "div", division
      ;; << a, b -- quotient >>
      xx divmod, drop
      xx end

   define_function "mod", modulo
      ;; << a, b -- a mod b >>
      xx moddiv, drop
      xx end
   #+end_src
** ----------------------------------
** equal? & greater-than? & less-than?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "equal?", equal?
      ;; << a, b -- a, b, true of false >>
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rbx, rax
      sete  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "less-than?", less_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setl  al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-than?", greater_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setg  al
      movzx rax, al
      push_argument_stack  rax
      next

   define_primitive_function "less-or-equal?", less_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setle al
      movzx rax, al
      push_argument_stack rax
      next

   define_primitive_function "greater-or-equal?", greater_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setge al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** negative? & positive?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "negative?", negative?
      ;; << integer -- bool >>
      xx zero, less_than?
      xx end

   define_function "positive?", positive?
      ;; << integer -- bool >>
      xx negative?, false?
      xx end
   #+end_src
** ----------------------------------
* memory
** note
   * although the following functions are all side-effect
     but I use "save" instead of "save!"
** save  [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   ;; "save" and "fetch" default to a jo_size
   ;; the rule of "fetch2" and so on are:
   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ||  1 : value-2  ||
   ;;     ||  1 : value-3  ||
   ;;     ...
   ;;   on stack:
   ;;     << value-1, value-2, value-3, ... >>
   ;; of course we have:
   ;;   fetch2 : memory=copy=>stack
   ;;   save2  : stack->memory

   define_primitive_function "save", save
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov [rbx], rax
      next

   define_primitive_function "save-byte", save_byte
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov byte[rbx], al
      next

   define_primitive_function "save-two-bytes", save_two_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov word [rbx], ax
      next

   define_primitive_function "save-four-bytes", save_four_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov dword [rbx], eax
      next

   define_primitive_function "n-save", n_save
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      mov rax, jo_size
      imul rax, rcx
      add rdx, rax
      ;; for address is based on 0
      ;; but n is based on 1
      sub rdx, jo_size
   .loop:
      pop_argument_stack rax
      mov dword [rdx], rax
      sub rdx, jo_size
      loop .loop
      next

   define_function "save2", save2
      ;; << value-2, value-1, address -- >>
      xx literal, 2
      xx n_save
      xx end

   define_primitive_function "n-save-byte", n_save_byte
      ;; << value-n, ..., value-1, address, n -- >>
      pop_argument_stack rcx
      pop_argument_stack rdx
      add rdx, rcx
      dec rdx
   .loop:
      pop_argument_stack rax
      mov byte [rdx], al
      dec rdx
      loop .loop
      next

   define_primitive_function "add-save", add_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      add dword [rbx], rax
      next

   define_primitive_function "sub-save", sub_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      sub dword [rbx], rax
      next

   }
   #+end_src
** fetch [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   define_primitive_function "fetch", fetch
      ;; ( address -- value )
      pop_argument_stack  rbx
      mov rax, [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-byte", fetch_byte
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte[rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-two-bytes", fetch_two_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov ax, word [rbx]
      push_argument_stack rax
      next

   define_primitive_function "fetch-four-bytes", fetch_four_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov eax, dword [rbx]
      push_argument_stack rax
      next

   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ...
   ;;     ||  1 : value-n  ||
   define_primitive_function "n-fetch", n_fetch
      ;; << address, n -- value-1, ..., value-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
   .loop:
      mov rax, dword [rdx]
      push_argument_stack rax
      add rdx, jo_size
      loop .loop
      next

   define_primitive_function "n-fetch-byte", n_fetch_byte
      ;; << address, n -- byte-1, ..., byte-n >>
      pop_argument_stack  rcx
      pop_argument_stack  rdx
      xor rax, rax
   .loop:
      mov al, byte [rdx]
      push_argument_stack rax
      inc rdx
      loop .loop
      next

   define_function "fetch2", fetch2
      ;; << address -- value-1, value-2 >>
      xx literal, 2
      xx n_fetch
      xx end

   }
   #+end_src
* -----------------------------------
* basic io
** ----------------------------------
** note byte
   * basic io is about byte
** ----------------------------------
** write-byte [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   buffer$write_byte:
      db 0

   __counter$write_byte:
      xx 0

   define_primitive_function "write-byte", write_byte
      ;; << byte -- >>
      ;; just calls the Linux write system call
      pop_argument_stack rax
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [buffer$write_byte], al

      push 0
      push __counter$write_byte
      push 1
      push buffer$write_byte
      mov rax, [_output_handle]
      push rax
      call [WriteFile]

      next

   }
   #+end_src
** ----------------------------------
** note
   * calls the linux read system call to fill buffer$read_byte
   * do not exit the program
     when meeting <end-of-file>
     so
     when you hit <C-d>
     some you will not exit the interpreter
   * add the feature to unread one ket-char
** note factoring
   * reading from file of stdin is slow
     thus
     1. when reading from file
        a whole file is readed at a time
        and saved to a buffer
     2. when reading from stdin
        a whole line is readed at a time
     3. note that
        reading line instead of keyboard-code
        will limit the design of the user interface
   * by factoring out the low-level calls
     that read a line from stdin
     we are able to implement eval-string easily
** note nested call of eval-string
   * nested call of eval-string is handled
     by using a eval_string_stack
     to remember the old string
   * but
     in my view
     meta-programming should NOT
     be achieved by editing string
   * note that
     this point of view
     is not conflict with my macro system
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_input_length = 1024 * 1024

   buffer$read_byte labeling
      preserve max_input_length
   #+end_src
** eval_string_stack
*** note
    * for we do not build border-check
      into the interface of pop and push
      we allocation some memory below the stacks
    * the size$eval_string_stack
      defines the max depth
      of nested call to eval string
    * cursor and border of a evaled string
      can be stored in eval_string_stack
      so
      when evaling a string
      the eval_string_stack will be
      << counter, cursor >>
      when evaling is nested depth is 2
      << counter, cursor, counter, cursor >>
*** memory allocation
    #+begin_src fasm :tangle cicada-nymph.fasm
    size$eval_string_stack = 1024 * jo_size

       preserve 64 * jo_size
    address$eval_string_stack labeling
       preserve size$eval_string_stack
    #+end_src
*** pointer
    #+begin_src fasm :tangle cicada-nymph.fasm
    pointer$eval_string_stack:
       xx address$eval_string_stack
    #+end_src
*** push & pop [64bit]
    #+begin_src fasm :tangle cicada-nymph.fasm
    match =64bit, machine {

     define_primitive_function "push-eval-string-stack", push_eval_string_stack
        ;; argument-stack -> eval-string-stack
        pop_argument_stack rax
        mov rbx, [pointer$eval_string_stack]
        mov [rbx], rax
        add qword [pointer$eval_string_stack], jo_size
        next

     define_primitive_function "pop-eval-string-stack", pop_eval_string_stack
        ;; eval-string-stack -> argument-stack
        sub qword [pointer$eval_string_stack], jo_size
        mov rbx, [pointer$eval_string_stack]
        mov rax, [rbx]
        push_argument_stack rax
        next

    }
    #+end_src
*** push & pop [32bit]
    #+begin_src fasm :tangle cicada-nymph.fasm
    match =32bit, machine {

     define_primitive_function "push-eval-string-stack", push_eval_string_stack
        ;; argument-stack -> eval-string-stack
        pop_argument_stack rax
        mov rsi, [pointer$eval_string_stack]
        mov [rsi], rax
        add dword [pointer$eval_string_stack], jo_size
        next

     define_primitive_function "pop-eval-string-stack", pop_eval_string_stack
        ;; eval-string-stack -> argument-stack
        sub dword [pointer$eval_string_stack], jo_size
        mov rsi, [pointer$eval_string_stack]
        mov rax, [rsi]
        push_argument_stack rax
        next

    }
    #+end_src
*** clear [64bit]
    #+begin_src fasm :tangle cicada-nymph.fasm
    match =64bit, machine {

    define_primitive_function "clear-eval-string-stack", clear_eval_string_stack
       ;; << -- >>
       mov qword [pointer$eval_string_stack], address$eval_string_stack
       next

    }
    #+end_src
*** clear [32bit]
    #+begin_src fasm :tangle cicada-nymph.fasm
    match =32bit, machine {

    define_primitive_function "clear-eval-string-stack", clear_eval_string_stack
       ;; << -- >>
       mov eax, address$eval_string_stack
       mov dword [pointer$eval_string_stack], eax;address$eval_string_stack
       next

    }
    #+end_src
*** empty?
    #+begin_src fasm :tangle cicada-nymph.fasm
    define_primitive_function "eval-string-stack-empty?", eval_string_stack_empty?
       ;; << -- bool >>
       mov rax, [pointer$eval_string_stack]
       cmp rax, address$eval_string_stack
       ;; less-than is treated as equal
       setle al
       movzx rax, al
       push_argument_stack rax
       next
    #+end_src
** read-line-from-stdin [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   __counter$read_line_from_stdin:
      xx 0

   define_primitive_function "read-line-from-stdin", read_line_from_stdin
      ;; << buffer address, max length -- >>
      push 0
      push __counter$read_line_from_stdin
      pop_argument_stack rax
      push rax
      pop_argument_stack rax
      push rax
      mov rax, [_input_handle]
      push rax
      call [ReadFile]
      ;; the return value
      ;; is a count of the number of bytes transferred
      mov rax, [__counter$read_line_from_stdin]
      push_argument_stack rax

      next

   }
   #+end_src
** test read-line-from-stdin
   #+begin_src fasm
   define_function "", test__read_line_from_stdin
      xx literal, buffer$read_byte
      xx literal, max_input_length
      xx read_line_from_stdin
      xx pretty_write_integer
      xx literal, buffer$read_byte
      xx literal, 10
      xx write_string
      xx exit_with_TOS
      xx end
   #+end_src
** read-byte
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-byte", read_byte
      ;; << -- byte >>
      xx have_unreaded_ket_char?, false?branch, 9
      xx   literal, char$unreaded_ket_char, fetch_byte
      xx   zero, literal, flag$unreaded_ket_char
      xx   save
      xx   end
      xx read_byte__without_unread
      xx end

   define_function "read-byte,without-unread", read_byte__without_unread
      ;; << -- byte >>
      xx eval_string_stack_empty?, false?branch, (.not_empty-$)/jo_size
      xx   literal, buffer$read_byte
      xx   literal, max_input_length
      xx   read_line_from_stdin
      xx     dup, positive?, false?, false?branch, 4
      ;;     ignore <end-of-file>
      ;;     ignore reading error
      xx     drop
      xx     taca, read_byte__without_unread
      xx   push_eval_string_stack
      xx   literal, buffer$read_byte
      xx   push_eval_string_stack
      xx   taca, read_byte__without_unread
      .not_empty:
      xx pop_eval_string_stack
      xx pop_eval_string_stack
      xx dup, zero?, false?branch, 4
      xx   drop2
      xx   taca, read_byte__without_unread
      xx sub1, push_eval_string_stack
      xx dup
      xx add1, push_eval_string_stack
      xx fetch_byte
      xx end
   #+end_src
** unread-ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   flag$unreaded_ket_char:
      xx 0

   char$unreaded_ket_char:
      xx 0

   define_function "have-unreaded-ket-char?", have_unreaded_ket_char?
      ;; << -- bool >>
      xx literal, flag$unreaded_ket_char
      xx fetch
      xx end

   define_function "unread-ket-char", unread_ket_char
      ;; << char -- >>
      xx literal, char$unreaded_ket_char, save
      xx true, literal, flag$unreaded_ket_char
      xx save
      xx end
   #+end_src
** ----------------------------------
* -----------------------------------
* char
** space-char?
   * as for space-char
     I only use two
     ASCII 10 (newline)
     ASCII 32 (whitespace)
   * note that
     I use the term "whitespace" to denotes the char
     I use the term "space" to denotes the set of chars
   * I will simply view number less-or-equal 32 as space-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-char?", space_char?
      ;; << char -- bool >>
      xx literal, 32
      xx less_or_equal?
      xx end
   #+end_src
** bar-ket-char?
   * () [] {}
     but not <>
   * double-quote is viewed as special bar-ket-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "bar-ket-char?", bar_ket_char?
      ;; << char -- bool >>
      xx dup, literal, '(', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ')', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '[', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, ']', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '{', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '}', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx dup, literal, '"', equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** decimal-digital-char?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digital-char?", decimal_digital_char?
      ;; << char -- bool >>
      xx dup, literal, '0', less_than?, false?branch, 4
      xx   drop, false
      xx   end
      xx dup, literal, '9', less_or_equal?, false?branch, 4
      xx   drop, true
      xx   end
      xx drop, false
      xx end
   #+end_src
** note digital
   * a decimal-digital is number from 0 to 9
   * a binary-digital is number from 0 to 1
** char->decimal-digital & decimal-digital->char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char->decimal-digital", char_to_decimal_digital
      ;; << char -- decimal-digital >>
      xx literal, '0'
      xx subtraction
      xx end

   define_function "decimal-digital->char", decimal_digital_to_char
      ;; << decimal-digital -- char >>
      xx literal, '0'
      xx addition
      xx end
   #+end_src
* buffer
** note
   * a buffer is a large vector
     and some functions do not care about how large it is
** compare-buffer
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; return false when length == 0
   define_primitive_function "compare-buffer", compare_buffer
      ;; << address, address, length -- bool >>
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      repe cmpsb
      sete al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
* string
** ----------------------------------
** note io about string
** write-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-string", write_string
      ;; << string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end
      xx sub1, swap
      xx dup, fetch_byte, write_byte
      xx add1, swap
      xx taca, write_string
   #+end_src
** pretty_write_string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function ".s", pretty_write_string
      ;; << integer -- >>
      xx write_string
      xx literal, 10
      xx write_byte
      xx end
   #+end_src
** ----------------------------------
** string-equal?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-equal?", string_equal?
      ;; << string[address, length], string[address, length] -- bool >>
      xx xoverxx, equal?, false?branch, 4
      xx   swap
      xx   compare_buffer
      xx   end
      xx drop, drop2
      xx false
      xx end
   #+end_src
** string-[head|tail],char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,char", string_head__char
      ;; << string[address, length] -- char >>
      xx drop, fetch_byte
      xx end

   define_function "string-tail,char", string_tail__char
      ;; << string[address, length] -- [address + 1, length + 1] >>
      xx sub1, swap
      xx add1
      xx swap
      xx end
   #+end_src
** string->buffer!
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_primitive_function "string->buffer!", string_to_buffer!
      ;; ( string[address, length], buffer[address] -- )
      pop_argument_stack rdi ;; destination
      pop_argument_stack rcx ;; counter
      pop_argument_stack rsi ;; source
      rep movsb
      next
   #+end_src
** string-reverse! [64bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =64bit, machine {

   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rdi, buffer$string_reverse!
      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
      rep movsb

      mov rcx, [pointer$argument_stack - (1 * jo_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [pointer$argument_stack - (2 * jo_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next

   }
   #+end_src
** string-reverse! [32bit]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =32bit, machine {

   buffer$string_reverse! labeling
      preserve 1024


   define_primitive_function "string-reverse!", string_reverse!
      ;; << string[address, length] -- string[address, length] >>
      mov rbx, [pointer$argument_stack]
      mov rdi, buffer$string_reverse!
      mov rcx, [rbx - (1 * jo_size)]
      mov rsi, [rbx - (2 * jo_size)]
      rep movsb

      mov rcx, [rbx - (1 * jo_size)]
      dec rdi ;; cursor back into string in buffer$string_reverse!
      mov rsi, [rbx - (2 * jo_size)]
   .loop:
      mov al, byte [rdi]
      mov byte [rsi], al
      dec rdi
      inc rsi
      loop .loop

      next

   }
   #+end_src
** digital-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "digital-string?", digital_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx over, fetch_byte, decimal_digital_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, digital_string?
      xx drop2, false
      xx end
   #+end_src
** char-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "char-string?", char_string?
      ;; << string[address, length], char -- bool >>
      xx xxswapx
      xx dup, one?, false?, false?branch, 5
      xx   drop2, drop
      xx   false
      xx   end
      xx string_head__char, equal?, false?branch, 3
      xx   true
      xx   end
      xx false
      xx end
   #+end_src
** zero-string?
   * "0" or "-0"
     0 is special when compiling literal number
     for we are using 0 as "end"
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "zero-string?", zero_string?
      ;; << string[address, length] -- bool >>
      xx dup2, literal, '0', char_string?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2
      xx string_head__char, literal, '-', equal?, false?, false?branch, 4
      xx   drop2, false
      xx   end
      xx string_tail__char, literal, '0', char_string?
      xx end
   #+end_src
** integer-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "integer-string?", integer_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, literal, '-', char_string?, false?branch, 4
      xx   drop2, false
      xx   end
      xx dup2, string_head__char, literal, '-', equal?, false?branch, 4
      xx   string_tail__char
      xx   digital_string?
      xx   end
      xx digital_string?
      xx end
   #+end_src
** string->integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->integer", string_to_integer
      ;; << string[address, length] -- integer >>
      xx dup2, string_head__char, literal, '-', equal?, false?, false?branch, 3
      xx   digital_string_to_integer
      xx   end
      xx string_tail__char
      xx digital_string_to_integer
      xx negate
      xx end


   sum$digital_string_to_integer:
      xx 0

   counter$digital_string_to_integer:
      xx 0

   define_function "digital-string->integer", digital_string_to_integer
      ;; << string[address, length] -- integer >>
      xx zero, literal, sum$digital_string_to_integer, save
      xx zero, literal, counter$digital_string_to_integer, save

      xx dup2, string_reverse!
      xx   help__digital_string_to_integer
      xx string_reverse!, drop2

      xx literal, sum$digital_string_to_integer
      xx fetch
      xx end

   define_function "help,digital-string->integer", help__digital_string_to_integer
      ;; << reversed-string[address, length] -- >>
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   end

      xx dup2, string_head__char, char_to_decimal_digital
      xx   literal, 10
      xx   literal, counter$digital_string_to_integer, fetch
      xx     one
      xx     literal, counter$digital_string_to_integer
      xx     add_save
      xx   power
      xx multiple

      xx literal, sum$digital_string_to_integer
      xx add_save

      xx string_tail__char
      xx taca, help__digital_string_to_integer
   #+end_src
** ----------------------------------
** find-char,string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "find-char,string", find_char__string
     ;; << found:
     ;;      string[address, length], char -- address, true >>
     ;; << not found:
     ;;      string[address, length], char -- false >>
     xx over, zero?, false?branch, 5
     xx   drop, drop2
     xx   false
     xx   end
     xx xoverxx, fetch_byte
     xx over, equal?, false?branch, 4
     xx   drop2
     xx   true
     xx   end
     xx xxswapx
     xx string_tail__char
     xx xswapxx
     xx taca, find_char__string
   #+end_src
** test
   #+begin_src cicada-nymph
   : XIE Yuheng ;
   32 find-char,string . << 1 >>
   fetch-byte . << 32 >>
   #+end_src
** ----------------------------------
* io about number
** write-nature-number
   #+begin_src fasm :tangle cicada-nymph.fasm
   ;; 2 ^ 64 = 18446744073709551616
   ;; which is of length 20
   ;; so
   ;; I use 32 to align to 16

   buffer$write_nature_number labeling
      preserve 32

   counter$write_nature_number:
      xx 0


   define_function "write-nature-number", write_nature_number
      ;; << nature-number -- >>
      xx zero
      xx literal, counter$write_nature_number, save

      xx help__write_nature_number

      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx string_reverse!
      xx write_string
      xx end


   define_function "help,write-nature-number", help__write_nature_number
      ;; << rest-number -- >>
      xx literal, 10, divmod

      xx decimal_digital_to_char
      xx literal, buffer$write_nature_number
      xx literal, counter$write_nature_number, fetch
      xx addition
      xx save_byte

      xx one
      xx literal, counter$write_nature_number
      xx add_save

      xx dup, zero?, false?branch, 3
      xx   drop
      xx   end
      xx taca, help__write_nature_number
   #+end_src
** write-integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "write-integer", write_integer
      ;; << integer -- >>
      xx dup, positive?, false?branch, 3
      xx   write_nature_number
      xx   end
      xx literal, '-', write_byte
      xx negate
      xx write_nature_number
      xx end
   #+end_src
** pretty_write_integer
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function ".", pretty_write_integer
      ;; << integer -- >>
      xx write_integer
      xx literal, 32
      xx write_byte
      xx end
   #+end_src
* word
** ----------------------------------
** note io about word
   * words are separated by spaces
   * a bar-ket is a word
     even when there are no spaces around it
** memory allocation
   #+begin_src fasm :tangle cicada-nymph.fasm
   max_word_length = 1024

   buffer$read_word labeling
      preserve max_word_length

   buffer$read_word_for_REPL labeling
      preserve max_word_length
   #+end_src
** read-word-begin-char
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-begin-char", read_word_begin_char
      ;; << -- non-blank-char >>
      xx read_byte
      xx dup, literal, 32 ;; ascii.space
      xx greater_than?, false?branch, 2
      xx   end
      xx drop
      xx taca, read_word_begin_char
   #+end_src
** read-word->buffer
   1. skip any space-char (whitespace newline)
   2. call read_char to read characters into buffer
      until it hits a blank
   3. return the address of buffer and length to argument_stack
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word->buffer", read_word_to_buffer
      ;; << buffer -- word[address, length] >>
      xx read_word_begin_char
      ;; no metter what the begin char is
      ;; save it into buffer
      xx dup2, swap, save_byte
      xx swap, add1, swap
      xx one, swap ;; leave length counter
      ;; << cursor[address in buffer], counter, begin char >>
      xx dup, bar_ket_char?, false?branch, 4
      xx   drop
      xx   help__read_word_to_buffer__bar_ket
      xx   end
      ;; maybe add other type of chars
      xx drop
      xx help__read_word_to_buffer__regular
      xx end

   define_function "help,read-word->buffer,bar-ket", help__read_word_to_buffer__bar_ket
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx tuck, subtraction
      xx swap
      xx end


   define_function "help,read-word->buffer,regular", help__read_word_to_buffer__regular
      ;; << cursor[address in buffer], counter -- word[address, length] >>
      xx read_byte
      xx dup, bar_ket_char?, false?branch, 6
      xx   unread_ket_char
      xx   tuck, subtraction
      xx   swap
      xx   end
      xx dup, space_char?, false?branch, 6
      xx   drop
      xx   tuck, subtraction
      xx   swap
      xx   end
      xx xoverxx, save_byte
      xx add1
      xx swap, add1, swap
      xx taca, help__read_word_to_buffer__regular
   #+end_src
** read-word
   * read-word will override the word readed before
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word", read_word
      ;; << -- word[address of buffer$read_word, length] >>
      xx literal, buffer$read_word, read_word_to_buffer
      xx end
   #+end_src
** read-word-for-REPL
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "read-word-for-REPL", read_word_for_REPL
      ;; << -- word[address of buffer$read_word_for_REPL, length] >>
      xx literal, buffer$read_word_for_REPL, read_word_to_buffer
      xx end
   #+end_src
** ----------------------------------
** note
   * one should use space-string? to make sure
     that the string is not space-string
     before apply string-[head|tail],word onto the string
** space-string?
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "space-string?", space_string?
      ;; << string[address, length] -- bool >>
      xx dup, zero?, false?branch, 4
      xx   drop2, true
      xx   end
      xx dup2, string_head__char, space_char?, false?branch, 4
      xx   string_tail__char
      xx   taca, space_string?
      xx drop2, false
      xx end
   #+end_src
** string->word-[begin|end]
   * the error is not handled
     so
     before calling (string->word-begin)
     one should make sure that
     the argument is not a space-string
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string->word-begin", string_to_word_begin
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, string_to_word_begin

   define_function "string->word-end", string_to_word_end
      ;; << string[address, length] -- string[address, length] >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 3
      xx   string_tail__char
      xx   end
      xx help__string_to_word_end
      xx end

   define_function "help,string->word-end", help__string_to_word_end
      ;; << string[address, length] -- address >>
      xx dup, zero?, false?branch, 2
      ;;   no error handling
      xx   end
      xx dup2, string_head__char
      xx space_char?, false?branch, 2
      xx   end
      xx dup2, string_head__char
      xx bar_ket_char?, false?branch, 2
      xx   end
      xx string_tail__char
      xx taca, help__string_to_word_end
   #+end_src
** string-[head|tail],word
   * note that
     the following functions do not create new strings
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "string-head,word", string_head__word
      ;; << string[address, length] -- word[address, length] >>
      xx string_to_word_begin
      xx dup2, string_to_word_end
      xx swap, drop
      xx subtraction
      xx end

   define_function "string-tail,word", string_tail__word
      ;; << string[address, length] -- string[address, length] >>
      xx string_to_word_begin
      xx string_to_word_end
      xx end
   #+end_src
** ----------------------------------
* dictionary
** note
   * the dictionary is a single-linked-list
     of word-jo-jojo
   * a jojo is an vector of jo
   * from a jo one can find a jojo
     for example
     this is what the "explain$function" will do
     to help the interpreter
     to explain the mean of a jo
   * from a word one can find a jo
     for example
     this is what the "define-function" will do
     from source code
     it defines new function into dictionary
     by creating new structured data into memory
** find
   * as find
   * find jo in dictionary by word
     but I simply call it "find"
   * a function whoes name is prefixed by "find"
     maybe fail to find
     and maybe returns a signal
     to inform the function who calls it
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*first-jo-in-dictionary*", V__first_jo_in_dictionary
      xx (last_link + jo_size)

   define_function "find", find
      ;; found :
      ;; << word[address, length] -- jo, true >>
      ;; not found :
      ;; << word[address, length] -- false >>
      xx V__first_jo_in_dictionary
      xx help__find
      xx end

   define_function "help,find", help__find
      ;; found :
      ;; << word[address, length], jo -- jo, true >>
      ;; not found :
      ;; << word[address, length], jo -- false >>
      xx xxtuckx


      xx jo_to_name, xxoverxx

      ;; for debug
      ;; xx jo_to_name
      ;; xx   dup2
      ;; xx   dup, write_integer, literal, 32, write_byte
      ;; xx   write_string, literal, 10, write_byte
      ;; xx xxoverxx
      ;; xx   dup2
      ;; xx   dup, write_integer, literal, 32, write_byte
      ;; xx   write_string, literal, 10, write_byte


      xx string_equal?, false?branch, 4
      xx   drop2, true
      xx   end
      xx xswapxx
      xx dup, last_jo__dictionary?, false?branch, 5
      xx   drop, drop2
      xx   false
      xx   end
      xx jo_to_pre_jo
      xx taca, help__find
   #+end_src
** execute-word
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_function "execute-word", execute_word
      ;; << word[address, length] -- unknown >>
      xx dup2, integer_string?, false?branch, 3
      xx   string_to_integer
      xx   end
      ;; maybe more

      xx dup2 ;; for to report undefined word

      xx find, false?branch, 5
      xx   xxswapx, drop2
      xx   execute_jo
      xx   end

      xx write_undefined_word_report__for_execute_word
      xx write_string
      xx literal, 10
      xx write_byte
      xx end


   define_function "write-undefined-word-report,for-execute-word", write_undefined_word_report__for_execute_word
      ;; << -- >>
      xx literal, string$undefined_word_report__for_execute_word
      xx literal, length$undefined_word_report__for_execute_word
      xx write_string
      xx end

   string$undefined_word_report__for_execute_word:
      db "* (execute-word) MEETS UNDEFINED WORD : "
   .end:
   length$undefined_word_report__for_execute_word = (.end - string$undefined_word_report__for_execute_word)
   #+end_src
* basic-REPL
  #+begin_src fasm :tangle cicada-nymph.fasm
  define_function "basic-REPL", basic_REPL
     ;; << UNKNOWN -- UNKNOWN >>
     xx read_word_for_REPL
     xx execute_word
     xx taca, basic_REPL
  #+end_src
* -----------------------------------
* epilog
** ----------------------------------
** *un-initialized-memory*
   #+begin_src fasm :tangle cicada-nymph.fasm
   define_variable "*un-initialized-memory*", V__un_initialized_memory
     xx address$un_initialized_memory

   define_variable "*size,un-initialized-memory*", V__size__un_initialized_memory
     xx size$un_initialized_memory

   define_variable "*current-free-address,un-initialized-memory*", V__current_free_address__un_initialized_memory
     xx current_free_address$un_initialized_memory
   #+end_src
** ----------------------------------
** last_link
   * this word helps to initialize V__first_jo_in_dictionary
   #+begin_src fasm :tangle cicada-nymph.fasm
   last_link = link
   #+end_src
** ----------------------------------
** un_initialized_memory [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

   section '.data' data readable writeable
   address$un_initialized_memory:
      rb size$un_initialized_memory

   }
   #+end_src
** macro about import    [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   if platform eq windows
   if machine eq 32bit

   ; Macroinstructions for making import section

   macro library [name,string] {
      common
       import.data:
      forward
       local _label
       if defined name#.redundant
        if ~ name#.redundant
         dd RVA name#.lookup,0,0,RVA _label,RVA name#.address
        finish if
       finish if
       name#.referred = 1
      common
       dd 0,0,0,0,0
      forward
       if defined name#.redundant
        if ~ name#.redundant
         _label db string,0
                rb RVA $ and 1
        finish if
       finish if
   }

   macro import name,[label,string]
    { common
       rb (- rva $) and 3
       if defined name#.referred
        name#.lookup:
      forward
        if used label
         if string eqtype ''
          local _label
          dd RVA _label
         else
          dd 80000000h + string
         finish if
        finish if
      common
        if $ > name#.lookup
         name#.redundant = 0
         dd 0
        else
         name#.redundant = 1
        finish if
        name#.address:
      forward
        if used label
         if string eqtype ''
          label dd RVA _label
         else
          label dd 80000000h + string
         finish if
        finish if
      common
        if ~ name#.redundant
         dd 0
        finish if
      forward
        if used label & string eqtype ''
        _label dw 0
               db string,0
               rb RVA $ and 1
        finish if
      common
       finish if
   }

   finish if
   finish if
   #+end_src
** section about import  [windows32]
   #+begin_src fasm :tangle cicada-nymph.fasm
   match =windows =32bit, platform machine {

   section '.idata' import data readable writeable

   library kernel32,'KERNEL32.DLL'

   import kernel32,\
          ExitProcess,'ExitProcess',\
          ReadFile,'ReadFile',\
          WriteFile,'WriteFile',\
          GetStdHandle,'GetStdHandle',\
          CloseHandle, 'CloseHandle',\
          CreateFileA, 'CreateFileA'

   }
   #+end_src
** ----------------------------------
* ===================================
